<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Brain MRI Viewer - RadMentor</title>
    <link href="https://fonts.googleapis.com/css2?family=Rubik:wght@300;400;500;700&display=swap" rel="stylesheet"/>
    <style>
        /* Base styles for all themes */
        body {
            font-family: 'Rubik', sans-serif;
            margin: 0;
            transition: background-color 0.3s ease, color 0.3s ease;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: var(--bg-color);
            color: var(--text-color);
            flex-direction: column; /* Arrange items vertically */
            overflow: hidden; /* Prevent body scroll if content overflows slightly */
        }

        /* Light Theme Variables */
        body.light-theme {
            --bg-color: #f0f8ff; /* Very light blue/off-white background */
            --container-bg-color: #ffffff; /* Pure white container background */
            --text-color: #333333; /* Dark grey for general text */
            --heading-color: #0d47a1; /* Darker blue for headings */
            --box-bg-color: #e3f2fd; /* Light blue for boxes */
            --box-hover-bg-color: #bbdefb; /* Slightly darker light blue on hover */
            --box-border-color: #90caf9; /* Medium blue for box borders */
            --back-button-bg: #1e88e5; /* Standard blue button */
            --back-button-hover-bg: #1565c0; /* Darker blue button on hover */
            --slider-track-bg: #c5d9e8; /* Light blue for slider track */
            --slider-thumb-bg: #1e88e5; /* Blue for slider thumb */
            --annotation-text-color: #1a237e; /* Darker blue for annotation text */
            --annotation-bg-color: rgba(255, 255, 255, 0.95); /* More opaque white background */
            --annotation-border-color: #64b5f6; /* Light blue border */
            --annotation-line-color: #42a5f5; /* Medium blue for lines */
            --annotation-point-color: #f44336; /* Red dot for point */
        }

        /* Dark Theme Variables */
        body:not(.light-theme) {
            --bg-color: #004d5e;
            --container-bg-color: #043f4e;
            --text-color: #ffffff;
            --heading-color: #ffffff;
            --box-bg-color: #095a71;
            --box-hover-bg-color: #064a5c;
            --box-border-color: #043f4e;
            --back-button-bg: #00bcd4;
            --back-button-hover-bg: #0097a7;
            --slider-track-bg: #032b36; /* Darker track for dark theme */
            --slider-thumb-bg: #00bcd4; /* Brighter thumb for dark theme */
            --annotation-text-color: #e0f2f1; /* Light text for annotations */
            --annotation-bg-color: rgba(0, 0, 0, 0.85); /* More opaque black background */
            --annotation-border-color: #00bcd4; /* Accent color border */
            --annotation-line-color: #00bcd4; /* Accent color for lines */
            --annotation-point-color: #f44336; /* Red dot for point */
        }

        .viewer-container {
            background-color: var(--container-bg-color);
            border-radius: 12px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
            padding: 20px;
            margin: 20px auto;
            max-width: 800px; /* Wider to accommodate labels */
            width: 90%; /* Responsive width */
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: center; /* Center items horizontally */
        }

        .viewer-container h1 {
            color: var(--heading-color);
            font-size: 2.2rem;
            margin-bottom: 20px;
            text-align: center;
        }

        /* Image and Overlay Container */
        .image-wrapper {
            position: relative;
            width: 100%;
            padding-bottom: 100%; /* Creates a square aspect ratio for the image area (if images are square) */
            background-color: #000; /* Black background for imaging studies */
            border-radius: 8px;
            overflow: hidden; /* Hide anything outside the wrapper */
            box-shadow: inset 0 0 5px rgba(0,0,0,0.5);
        }

        .image-wrapper img {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain; /* Ensures the image fits within the wrapper without cropping */
            display: block;
            user-select: none;
            -webkit-user-drag: none;
            z-index: 8; /* Below labels and SVG lines */
        }

        /* SVG Overlay for Lines and Points */
        .annotation-svg-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 9; /* Above image, below labels */
            pointer-events: none; /* Crucial: allows clicks to pass through to image/labels */
            overflow: visible; /* Allows SVG elements to go slightly outside if needed */
        }
        .annotation-svg-overlay line {
            stroke: var(--annotation-line-color);
            stroke-width: 2;
            transition: opacity 0.3s ease;
            opacity: 0; /* Hidden by default */
            stroke-linecap: round;
        }
        .annotation-svg-overlay line.show {
            opacity: 0.7;
        }
        .annotation-svg-overlay circle {
            fill: var(--annotation-point-color);
            transition: opacity 0.3s ease;
            opacity: 0; /* Hidden by default */
        }
        .annotation-svg-overlay circle.show {
            opacity: 1;
        }


        /* Annotation Label Styling (HTML Divs) */
        .annotation-label {
            position: absolute;
            background-color: var(--annotation-bg-color);
            color: var(--annotation-text-color);
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.9rem;
            font-weight: 500;
            white-space: nowrap; /* Keep text on one line */
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            border: 1px solid var(--annotation-border-color);
            z-index: 11; /* Ensure labels are on top */
            cursor: default;
            
            /* Center the label div on its (left, top) coordinates */
            transform: translate(-50%, -50%); 

            /* Visibility control */
            opacity: 0; 
            transition: opacity 0.3s ease; 
            display: block; /* Ensure it's a block element */
        }

        .annotation-label.show {
            opacity: 1; /* Make visible when 'show' class is added */
        }

        .controls {
            width: 100%;
            margin-top: 25px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        #sliceSlider {
            width: 90%;
            -webkit-appearance: none;
            appearance: none;
            height: 8px;
            background: var(--slider-track-bg);
            outline: none;
            opacity: 0.9;
            transition: opacity .2s;
            border-radius: 5px;
        }

        #sliceSlider:hover {
            opacity: 1;
        }

        #sliceSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--slider-thumb-bg);
            cursor: grab;
            box-shadow: 0 0 5px rgba(0,0,0,0.3);
        }

        #sliceSlider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--slider-thumb-bg);
            cursor: grab;
            box-shadow: 0 0 5px rgba(0,0,0,0.3);
        }

        #sliceNumberDisplay {
            font-size: 1.1rem;
            color: var(--text-color);
            font-weight: 500;
        }

        .back-button {
            display: block;
            width: 200px;
            margin: 40px auto 0;
            padding: 15px 25px;
            background-color: var(--back-button-bg);
            color: white;
            text-align: center;
            border-radius: 5px;
            text-decoration: none;
            font-weight: bold;
            font-size: 1.1rem;
            transition: background-color 0.3s ease;
        }
        .back-button:hover {
            background-color: var(--back-button-hover-bg);
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .viewer-container {
                padding: 15px;
                width: 95%;
            }
            h1 {
                font-size: 2rem;
            }
        }
        @media (max-width: 480px) {
            h1 {
                font-size: 1.8rem;
            }
            .back-button {
                width: 100%;
                font-size: 1rem;
            }
        }
        /* Loading spinner CSS */
        .loading-overlay {
            position: fixed; /* Fixed to cover the entire viewport */
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.85); /* Slightly darker to ensure visibility */
            color: white;
            display: flex;
            flex-direction: column; /* Stack spinner and text */
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            z-index: 1000; /* Extremely high z-index to always be on top */
            transition: opacity 0.5s ease; /* Slower transition for effect */
            opacity: 1;
            pointer-events: auto; /* Block interaction when visible */
        }
        .loading-overlay.hidden {
            opacity: 0;
            pointer-events: none; /* Crucial: allows clicks through when hidden */
        }
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #fff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin-bottom: 10px; /* Space between spinner and text */
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="viewer-container">
        <h1>Axial Brain Anatomy</h1>

        <div class="image-wrapper">
            <img id="brainSliceImage" src="" alt="Brain Slice">
            <svg class="annotation-svg-overlay" id="annotationSvgOverlay"></svg>
            <div id="annotationOverlay"></div>
            
            <div class="loading-overlay" id="loadingOverlay">
                <div class="spinner"></div>&nbsp;Loading Annotations...
            </div>
        </div>

        <div class="controls">
            <input type="range" id="sliceSlider" min="1" max="24" value="1">
            <div id="sliceNumberDisplay">Slice: 1 / 24</div>
        </div>

        <a href="../../index.html" class="back-button">Back to MRI Anatomy</a>
    </div>

    <script>
    const imageCount = 24; 
    const imageBaseName = 'brain'; 
    const imageExtension = '.png'; 
    const imageFolderPath = './Images/'; 

    const annotationJsonPath = './annotations/'; 
    const imageDimensionMM = 512; // Used for coordinate scaling

    const brainSliceImage = document.getElementById('brainSliceImage');
    const sliceSlider = document.getElementById('sliceSlider');
    const sliceNumberDisplay = document.getElementById('sliceNumberDisplay');
    const annotationOverlay = document.getElementById('annotationOverlay'); // HTML div for labels
    const annotationSvgOverlay = document.getElementById('annotationSvgOverlay'); // SVG for lines/circles
    const loadingOverlay = document.getElementById('loadingOverlay');

    let allAnnotations = []; 
    let annotationsLoaded = false; 
    const preloadedImages = []; // Array to store preloaded Image objects for HTML img tag

    // --- THEME LOGIC (standard) ---
    function setTheme(theme) {
        if (theme === 'light') {
            document.body.classList.add('light-theme');
            localStorage.setItem('theme', 'light');
        } else {
            document.body.classList.remove('light-theme');
            localStorage.setItem('theme', 'dark');
        }
    }

    function setInitialTheme() {
        const savedTheme = localStorage.getItem('theme');
        if (savedTheme === 'light') {
            document.body.classList.add('light-theme');
        } else {
            document.body.classList.remove('light-theme');
        }
    }
    setInitialTheme();
    // --- END THEME LOGIC ---

    // --- JSON FILENAMES (CRITICAL: THIS LIST MUST BE EXACT) ---
    const jsonFilenames = [
        "Angular Gyrus.json", "Aqueduct.json", "Caudate Nucleus.json", "Central Lobule.json",
        "Cerebellar Nuclei.json", "Cerebellar Peduncles.json", "Culmen.json", "Cuneus.json",
        "Declive.json", "Flocculus.json", "Fornix.json", "Frontal horn of LV.json",
        "Globus Pallidus.json", "Inferior Frontal Gyrus.json", "Internal Capsule.json",
        "Interpeduncular cistern.json", "Lateral Occipitotemporal gyrus.json",
        "Maxillary Sinus.json", 
        "Medial Frontal Gyrus.json",
        "Medulla Oblongata.json",
        "Mesencephalic cistern.json",
        "Midbrain.json",
        "Middle Frontal Gyrus.json",
        "Olfactory Sulcus.json", 
        "Optic Nerve.json", "Peduncles.json", "Pons.json", "Post Central Gyrus.json",
        "Posterior horn of LV.json", "Pre Central Gyrus.json", "Precuneus.json", "Putamen.json",
        "Septum Pellucidum.json", "Straight Gyrus.json", "Superior Frontal Gyrus.json",
        "Superior Parietal Lobule.json", "Suprachiasmatic cistern.json", "Supramarginal Gyrus.json",
        "Thallamus.json" 
    ];
    // --- END JSON FILENAMES ---

    // --- Data Loading and Processing ---
    async function loadAnnotations() {
        console.log("loadAnnotations started."); 
        loadingOverlay.classList.remove('hidden'); 

        const fetchPromises = jsonFilenames.map(filename =>
            new Promise((resolve, reject) => { 
                const timeoutId = setTimeout(() => {
                    reject(new Error(`Fetch timed out for ${filename} after 10 seconds.`));
                }, 10000); 

                fetch(`${annotationJsonPath}${filename}`)
                    .then(response => {
                        clearTimeout(timeoutId); 
                        if (!response.ok) {
                            reject(new Error(`Failed to load ${filename}: ${response.statusText} (URL: ${response.url})`));
                        }
                        return response.json();
                    })
                    .then(jsonData => {
                        resolve(jsonData);
                    })
                    .catch(error => {
                        clearTimeout(timeoutId); 
                        reject(error); 
                    });
            })
        );

        try {
            const results = await Promise.all(fetchPromises);
            console.log("All JSON fetches and parsing completed."); 

            results.forEach(jsonData => {
                if (!jsonData || !jsonData.markups || !Array.isArray(jsonData.markups)) {
                    console.warn("Skipping invalid or empty JSON data for a markup file (missing 'markups' array).", jsonData);
                    return;
                }

                jsonData.markups.forEach(markup => {
                    if (markup.type === "Fiducial" && Array.isArray(markup.controlPoints)) {
                        markup.controlPoints.forEach(cp => {
                            if (cp.position && cp.position.length === 3) {
                                const sliceZ = cp.position[2]; 
                                const imageSliceNumber = Math.round(sliceZ); 

                                const pointX_percent = (cp.position[0] / imageDimensionMM) * 100;
                                const pointY_percent = (cp.position[1] / imageDimensionMM) * 100;

                                const cleanLabelText = cp.label.split(/-\d+/)[0].trim();

                                // For the label position, let's keep it close to the point but slightly offset
                                // You might need to fine-tune these offsets for your specific labels
                                const labelX = pointX_percent + 2; // Move slightly right
                                const labelY = pointY_percent - 2; // Move slightly up

                                allAnnotations.push({
                                    slice: imageSliceNumber,
                                    text: cleanLabelText,
                                    pointX: pointX_percent,
                                    pointY: pointY_percent,
                                    labelX: labelX, 
                                    labelY: labelY  
                                });
                            }
                        });
                    }
                });
            });
            console.log("All annotations processed. Total annotations:", allAnnotations.length); 
            annotationsLoaded = true; 

        } catch (e) {
            console.error("Critical error during annotation loading or processing:", e); 
            alert("A critical error occurred while loading annotations: " + e.message + ". Check console for network/parsing details."); 
            annotationsLoaded = false; 
        } finally {
            loadingOverlay.classList.add('hidden'); 
        }

        // Always attempt to updateSlice after annotations load, even if failed
        updateSlice(); 
    }

    // --- Image Preloading ---
    function preloadAllImages() {
        console.log("Preloading images initiated.");
        for (let i = 1; i <= imageCount; i++) {
            const img = new Image();
            img.src = `${imageFolderPath}${imageBaseName}${i}${imageExtension}`;
            preloadedImages.push(img); 
        }
    }

    // --- Display Logic ---
    function updateSlice() {
        const currentSlice = parseInt(sliceSlider.value); 
        const imageUrl = `${imageFolderPath}${imageBaseName}${currentSlice}${imageExtension}`; 
        
        if (brainSliceImage.src !== new URL(imageUrl, window.location.href).href) {
            brainSliceImage.src = imageUrl;
        }

        sliceNumberDisplay.textContent = `Slice: ${currentSlice} / ${imageCount}`;

        // Clear previous annotations and SVG elements
        annotationOverlay.innerHTML = ''; 
        annotationSvgOverlay.innerHTML = ''; 

        // Set up the onload handler for the image
        brainSliceImage.onload = function() {
            // Remove the onload handler after it fires
            this.onload = null; 

            const wrapperRect = brainSliceImage.parentElement.getBoundingClientRect();
            const imageWidth = wrapperRect.width;
            const imageHeight = wrapperRect.height;

            if (annotationsLoaded) {
                const annotationsForCurrentSlice = allAnnotations.filter(ann => ann.slice === currentSlice);
                // console.log(`Found ${annotationsForCurrentSlice.length} annotations for slice ${currentSlice}.`);

                annotationsForCurrentSlice.forEach(annotation => {
                    // Create HTML Label div
                    const labelDiv = document.createElement('div');
                    labelDiv.classList.add('annotation-label');
                    labelDiv.textContent = annotation.text;
                    labelDiv.style.left = `${annotation.labelX}%`;
                    labelDiv.style.top = `${annotation.labelY}%`;
                    annotationOverlay.appendChild(labelDiv);

                    // Create SVG Circle for the point
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    const pX = (annotation.pointX / 100) * imageWidth;
                    const pY = (annotation.pointY / 100) * imageHeight;
                    circle.setAttribute('cx', pX);
                    circle.setAttribute('cy', pY);
                    circle.setAttribute('r', 4); 
                    circle.classList.add('show');
                    annotationSvgOverlay.appendChild(circle);

                    // Add 'show' class to HTML label to make it visible with transition
                    setTimeout(() => labelDiv.classList.add('show'), 10);
                });
            } else {
                console.warn("Annotations not yet loaded or failed to load. Skipping rendering of annotations for this slice.");
            }
        };

        // If the image is already loaded (from cache or preloading), trigger the onload manually
        if (brainSliceImage.complete) {
            brainSliceImage.onload(); 
        }
    }

    // --- Initial Setup ---
    document.addEventListener('DOMContentLoaded', () => {
        console.log("DOM content loaded. Initializing viewer."); 
        preloadAllImages(); 
        loadAnnotations(); 
    });

    // Use 'change' event for slider to avoid excessive updates during drag
    sliceSlider.addEventListener('change', updateSlice); 
    
    // Debounced resize event listener
    let resizeTimeout;
    window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
            console.log("Window resized, updating slice.");
            updateSlice();
        }, 100); 
    });
</script>
</body>
</html>
