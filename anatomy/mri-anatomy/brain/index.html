<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Brain MRI Viewer - RadMentor</title>
    <link href="https://fonts.googleapis.com/css2?family=Rubik:wght@300;400;500;700&display=swap" rel="stylesheet"/>
    <style>
        /* TEMPORARY DEBUGGING STYLES - REMOVE AFTER FIXING */
.viewer-container {
    border: 3px dashed purple !important;
    min-height: 500px !important; /* Ensure it has some height */
    max-width: 1200px !important; /* Ensure it's wide enough */
    width: 95% !important;
}

.viewer-content-area {
    border: 3px dashed orange !important;
    min-height: 400px !important; /* Ensure it has some height */
    width: 100% !important;
    display: flex !important; /* Ensure flexbox is applied */
    flex-wrap: nowrap !important; /* Prevent wrapping unexpectedly */
    justify-content: center !important; /* Center content */
    align-items: flex-start !important; /* Align children to top */
    gap: 10px !important; /* Spacing between children */
}

.image-wrapper {
    border: 3px dashed green !important;
    width: 512px !important; /* Confirm fixed width */
    height: 512px !important; /* Confirm fixed height */
    flex-shrink: 0 !important; /* Prevent shrinking */
}

.annotation-side-panel {
    background-color: #3333ff !important; /* Bright blue to see it */
    border: 2px solid yellow !important; /* Bright border */
    min-width: 150px !important; /* Ensure minimum width */
    max-width: 250px !important;
    height: 512px !important; /* Match image height */
    flex-grow: 1 !important; /* Allow it to grow */
    padding: 10px !important; /* Ensure padding is there */
}
/* END TEMPORARY DEBUGGING STYLES *//* Base styles for all themes */
        body {
            font-family: 'Rubik', sans-serif;
            margin: 0;
            transition: background-color 0.3s ease, color 0.3s ease;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: var(--bg-color);
            color: var(--text-color);
            flex-direction: column; /* Arrange items vertically */
            overflow-x: hidden; /* Prevent horizontal body scroll if content overflows slightly */
            overflow-y: auto; /* Allow vertical scroll for long pages */
        }

        /* Light Theme Variables */
        body.light-theme {
            --bg-color: #f0f8ff; /* Very light blue/off-white background */
            --container-bg-color: #ffffff; /* Pure white container background */
            --text-color: #333333; /* Dark grey for general text */
            --heading-color: #0d47a1; /* Darker blue for headings */
            --box-bg-color: #e3f2fd; /* Light blue for boxes */
            --box-hover-bg-color: #bbdefb; /* Slightly darker light blue on hover */
            --box-border-color: #90caf9; /* Medium blue for box borders */
            --back-button-bg: #1e88e5; /* Standard blue button */
            --back-button-hover-bg: #1565c0; /* Darker blue button on hover */
            --slider-track-bg: #c5d9e8; /* Light blue for slider track */
            --slider-thumb-bg: #1e88e5; /* Blue for slider thumb */
            --annotation-text-color: #1a237e; /* Darker blue for annotation text */
            --annotation-bg-color: rgba(255, 255, 255, 0.95); /* More opaque white background */
            --annotation-border-color: #64b5f6; /* Light blue border */
            --annotation-line-color: #42a5f5; /* Medium blue for lines */
            --annotation-point-color: #f44336; /* Red dot for point */
        }

        /* Dark Theme Variables */
        body:not(.light-theme) {
            --bg-color: #004d5e;
            --container-bg-color: #043f4e;
            --text-color: #ffffff;
            --heading-color: #ffffff;
            --box-bg-color: #095a71;
            --box-hover-bg-color: #064a5c;
            --box-border-color: #043f4e;
            --back-button-bg: #00bcd4;
            --back-button-hover-bg: #0097a7;
            --slider-track-bg: #032b36; /* Darker track for dark theme */
            --slider-thumb-bg: #00bcd4; /* Brighter thumb for dark theme */
            --annotation-text-color: #e0f2f1; /* Light text for annotations */
            --annotation-bg-color: rgba(0, 0, 0, 0.85); /* More opaque black background */
            --annotation-border-color: #00bcd4; /* Accent color border */
            --annotation-line-color: #00bcd4; /* Accent color for lines */
            --annotation-point-color: #f44336; /* Red dot for point */
        }

        .viewer-container {
            background-color: var(--container-bg-color);
            border-radius: 12px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
            padding: 20px;
            margin: 20px auto;
            max-width: 1200px; /* Wider to accommodate side panels */
            width: 95%; /* Responsive width */
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: center; /* Center items horizontally */
        }

        .viewer-container h1 {
            color: var(--heading-color);
            font-size: 2.2rem;
            margin-bottom: 20px;
            text-align: center;
        }

        /* NEW: Container for Image + Side Panels */
        .viewer-content-area {
            display: flex; /* Use flexbox to arrange items horizontally */
            width: 100%; /* Take full width of parent viewer-container */
            align-items: flex-start; /* Align items to the top */
            gap: 10px; /* Space between image and panels */
            justify-content: center; /* Center the image and panels as a group */
        }

        /* Update image-wrapper */
        .image-wrapper {
            position: relative;
            flex-shrink: 0; /* Don't allow it to shrink */
            width: 512px; /* Set a fixed width for the image area - ADJUST THIS TO YOUR IMAGE RESOLUTION */
            height: 512px; /* Set a fixed height for the image area - ADJUST THIS TO YOUR IMAGE RESOLUTION */
            background-color: #000; /* Black background for imaging studies */
            border-radius: 8px;
            overflow: hidden; /* Hide anything outside the wrapper */
            box-shadow: inset 0 0 5px rgba(0,0,0,0.5);
        }

        .image-wrapper img {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain; /* Ensures the image fits within the wrapper without cropping */
            display: block;
            user-select: none;
            -webkit-user-drag: none;
            z-index: 8; /* Below labels and SVG lines */
        }

        /* NEW: Side Panels */
        .annotation-side-panel {
            flex-grow: 1; /* Allow panels to grow and take available space */
            min-width: 150px; /* Minimum width for the panels */
            max-width: 250px; /* Max width to prevent them from becoming too wide */
            background-color: var(--container-bg-color); /* Match container background */
            border-radius: 8px;
            padding: 10px;
            box-sizing: border-box;
            position: relative; /* CRITICAL: For absolutely positioned labels WITHIN IT */
            height: 512px; /* Match image height - ADJUST THIS TO YOUR IMAGE RESOLUTION */
            overflow-y: auto; /* Allow scrolling if labels exceed height */
            /* Hide scrollbar for aesthetics */
            -ms-overflow-style: none; /* IE and Edge */
            scrollbar-width: none; /* Firefox */
        }
        .annotation-side-panel::-webkit-scrollbar { /* Chrome, Safari, Opera */
            display: none;
        }

        /* SVG Overlay for Lines and Points */
        .annotation-svg-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 9; /* Above image */
            pointer-events: none; /* Crucial: allows clicks to pass through to image/labels */
            overflow: visible; /* Allows SVG elements to go slightly outside if needed (e.g. to connect to panels) */
        }

        /* Lines are hidden by default, visible on hover */
        .annotation-svg-overlay line {
            stroke: var(--annotation-line-color);
            stroke-width: 2;
            transition: opacity 0.3s ease;
            opacity: 0; /* Hidden by default */
            stroke-linecap: round;
        }
        .annotation-svg-overlay line.visible-on-hover {
            opacity: 0.7;
        }

        /* Circles are always visible, can change on hover */
        .annotation-svg-overlay circle {
            fill: var(--annotation-point-color);
            transition: all 0.1s ease; /* Transition for 'r' (radius) */
            opacity: 1; /* Always visible */
        }
        .annotation-svg-overlay circle.visible-on-hover-circle {
            r: 6; /* Make radius slightly larger on hover */
        }

        /* Annotation Label Styling (HTML Divs - MODIFIED) */
        .annotation-label {
            position: absolute; /* Positioned absolutely within its parent panel */
            background-color: var(--annotation-bg-color);
            color: var(--annotation-text-color);
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.9rem;
            font-weight: 500;
            white-space: nowrap;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            border: 1px solid var(--annotation-border-color);
            z-index: 11; /* Ensure labels are on top of other content if they overlap something */
            cursor: default;
            
            /* Vertical centering is handled by translateY */
            transform: translateY(-50%); 

            /* Visibility control */
            opacity: 0; 
            transition: opacity 0.3s ease; 
            display: block; 
        }
        
        .annotation-label.show {
            opacity: 1;
        }

        .controls {
            width: 100%;
            margin-top: 25px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        #sliceSlider {
            width: 90%;
            -webkit-appearance: none;
            appearance: none;
            height: 8px;
            background: var(--slider-track-bg);
            outline: none;
            opacity: 0.9;
            transition: opacity .2s;
            border-radius: 5px;
        }

        #sliceSlider:hover {
            opacity: 1;
        }

        #sliceSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--slider-thumb-bg);
            cursor: grab;
            box-shadow: 0 0 5px rgba(0,0,0,0.3);
        }

        #sliceSlider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--slider-thumb-bg);
            cursor: grab;
            box-shadow: 0 0 5px rgba(0,0,0,0.3);
        }

        #sliceNumberDisplay {
            font-size: 1.1rem;
            color: var(--text-color);
            font-weight: 500;
        }

        .back-button {
            display: block;
            width: 200px;
            margin: 40px auto 0;
            padding: 15px 25px;
            background-color: var(--back-button-bg);
            color: white;
            text-align: center;
            border-radius: 5px;
            text-decoration: none;
            font-weight: bold;
            font-size: 1.1rem;
            transition: background-color 0.3s ease;
        }
        .back-button:hover {
            background-color: var(--back-button-hover-bg);
        }

        /* Responsive adjustments */
        @media (max-width: 1000px) { /* When screen is narrower, stack panels vertically */
            .viewer-content-area {
                flex-direction: column; /* Stack panels above/below image */
                align-items: center; /* Center image and panels */
                gap: 20px; /* More space when stacked */
            }
            .image-wrapper {
                width: 100%; /* Image takes full width now */
                max-width: 512px; /* Keep it from stretching too much on larger narrow screens */
                height: auto;
                padding-bottom: 100%; /* Maintain aspect ratio */
            }
            .annotation-side-panel {
                width: 100%; /* Panels take full width */
                max-width: 512px; /* Match image max-width */
                height: auto; /* Height adjusts to content */
                min-height: 80px; /* Ensure some height for stacked panels */
                display: flex; /* Flexbox for horizontal arrangement of labels inside */
                flex-direction: row; /* Labels flow horizontally */
                flex-wrap: wrap; /* Labels wrap to next line */
                justify-content: center; /* Center labels when wrapped */
                gap: 10px; /* Space between labels in stacked panels */
                padding: 15px;
            }
            .annotation-label {
                position: relative; /* Labels become relative within panels when stacked */
                top: auto;
                left: auto;
                right: auto;
                transform: none; /* Remove absolute positioning transforms */
                margin-top: 0; /* Reset margins if any were affecting vertical stacking */
            }
            .annotation-svg-overlay {
                display: none; /* Hide lines and points when layout changes dramatically (can't connect well) */
            }
        }

        @media (max-width: 768px) {
            .viewer-container {
                padding: 15px;
                width: 95%;
            }
            h1 {
                font-size: 2rem;
            }
        }
        @media (max-width: 480px) {
            h1 {
                font-size: 1.8rem;
            }
            .back-button {
                width: 100%;
                font-size: 1rem;
            }
        }
        /* Loading spinner CSS */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.85);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            z-index: 1000;
            transition: opacity 0.5s ease;
            opacity: 1;
            pointer-events: auto;
        }
        .loading-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #fff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin-bottom: 10px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="viewer-container">
        <h1>Axial Brain Anatomy</h1>

        <div class="viewer-content-area">
            <div class="annotation-side-panel left-panel" id="leftAnnotationPanel"></div>
            
            <div class="image-wrapper">
                <img id="brainSliceImage" src="" alt="Brain Slice">
                <svg class="annotation-svg-overlay" id="annotationSvgOverlay"></svg>
                <div id="annotationOverlay"></div> 
                
                <div class="loading-overlay" id="loadingOverlay">
                    <div class="spinner"></div>&nbsp;Loading Annotations...
                </div>
            </div>
            
            <div class="annotation-side-panel right-panel" id="rightAnnotationPanel"></div>
        </div>

        <div class="controls">
            <input type="range" id="sliceSlider" min="1" max="24" value="1">
            <div id="sliceNumberDisplay">Slice: 1 / 24</div>
        </div>

        <a href="../../index.html" class="back-button">Back to MRI Anatomy</a>
    </div>

    <script>
        const imageCount = 24; 
        const imageBaseName = 'brain'; 
        const imageExtension = '.png'; 
        const imageFolderPath = './Images/'; 

        const annotationJsonPath = './annotations/'; 
        const imageDimensionMM = 512; // Original dimension from 3D Slicer coordinates

        const brainSliceImage = document.getElementById('brainSliceImage');
        const sliceSlider = document.getElementById('sliceSlider');
        const sliceNumberDisplay = document.getElementById('sliceNumberDisplay');
        const annotationOverlay = document.getElementById('annotationOverlay'); // Not used for labels anymore
        const annotationSvgOverlay = document.getElementById('annotationSvgOverlay'); 
        const loadingOverlay = document.getElementById('loadingOverlay');

        // NEW: References to the side panels
        const leftAnnotationPanel = document.getElementById('leftAnnotationPanel');
        const rightAnnotationPanel = document.getElementById('rightAnnotationPanel');

        let allAnnotations = []; 
        let annotationsLoaded = false; 
        const preloadedImages = []; 

        // --- Configuration for aligned labels ---
        const LABEL_PANEL_PADDING = 10; // Padding inside the side panels in pixels
        const LABEL_SPACING = 8;       // Vertical spacing between stacked labels in pixels (increased for more gap)
        const LINE_TO_IMAGE_EDGE_OFFSET = 5; // How far into the image the line "stops" before connecting to the label

        // --- THEME LOGIC (standard) ---
        function setTheme(theme) {
            if (theme === 'light') {
                document.body.classList.add('light-theme');
                localStorage.setItem('theme', 'light');
            } else {
                document.body.classList.remove('light-theme');
                localStorage.setItem('theme', 'dark');
            }
        }

        function setInitialTheme() {
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme === 'light') {
                document.body.classList.add('light-theme');
            } else {
                document.body.classList.remove('light-theme');
            }
        }
        setInitialTheme();
        // --- END THEME LOGIC ---

        // --- JSON FILENAMES (CRITICAL: THIS LIST MUST BE EXACT) ---
        const jsonFilenames = [
            "Angular Gyrus.json", "Aqueduct.json", "Caudate Nucleus.json", "Central Lobule.json",
            "Cerebellar Nuclei.json", "Cerebellar Peduncles.json", "Culmen.json", "Cuneus.json",
            "Declive.json", "Flocculus.json", "Fornix.json", "Frontal horn of LV.json",
            "Globus Pallidus.json", "Inferior Frontal Gyrus.json", "Internal Capsule.json",
            "Interpeduncular cistern.json", "Lateral Occipitotemporal gyrus.json",
            "Maxillary Sinus.json", 
            "Medial Frontal Gyrus.json",
            "Medulla Oblongata.json",
            "Mesencephalic cistern.json",
            "Midbrain.json",
            "Middle Frontal Gyrus.json",
            "Olfactory Sulcus.json", 
            "Optic Nerve.json", "Peduncles.json", "Pons.json", "Post Central Gyrus.json",
            "Posterior horn of LV.json", "Pre Central Gyrus.json", "Precuneus.json", "Putamen.json",
            "Septum Pellucidum.json", "Straight Gyrus.json", "Superior Frontal Gyrus.json",
            "Superior Parietal Lobule.json", "Suprachiasmatic cistern.json", "Supramarginal Gyrus.json",
            "Thallamus.json" 
        ];
        // --- END JSON FILENAMES ---

        // --- Data Loading and Processing ---
        async function loadAnnotations() {
            console.log("loadAnnotations started."); 
            loadingOverlay.classList.remove('hidden'); 

            const fetchPromises = jsonFilenames.map(filename =>
                new Promise((resolve, reject) => { 
                    const timeoutId = setTimeout(() => {
                        reject(new Error(`Fetch timed out for ${filename} after 10 seconds.`));
                    }, 10000); 

                    fetch(`${annotationJsonPath}${filename}`)
                        .then(response => {
                            clearTimeout(timeoutId); 
                            if (!response.ok) {
                                reject(new Error(`Failed to load ${filename}: ${response.statusText} (URL: ${response.url})`));
                            }
                            return response.json();
                        })
                        .then(jsonData => {
                            resolve(jsonData);
                        })
                        .catch(error => {
                            clearTimeout(timeoutId); 
                            reject(error); 
                        });
                })
            );

            try {
                const results = await Promise.all(fetchPromises);
                console.log("All JSON fetches and parsing completed."); 

                results.forEach(jsonData => {
                    if (!jsonData || !jsonData.markups || !Array.isArray(jsonData.markups)) {
                        console.warn("Skipping invalid or empty JSON data for a markup file (missing 'markups' array).", jsonData);
                        return;
                    }

                    jsonData.markups.forEach(markup => {
                        if (markup.type === "Fiducial" && Array.isArray(markup.controlPoints)) {
                            markup.controlPoints.forEach(cp => {
                                if (cp.position && cp.position.length === 3) {
                                    const sliceZ = cp.position[2]; 
                                    const imageSliceNumber = Math.round(sliceZ); 

                                    const pointX_percent = (cp.position[0] / imageDimensionMM) * 100;
                                    const pointY_percent = (cp.position[1] / imageDimensionMM) * 100;

                                    const cleanLabelText = cp.label.split(/-\d+/)[0].trim();

                                    allAnnotations.push({
                                        slice: imageSliceNumber,
                                        text: cleanLabelText,
                                        pointX: pointX_percent, // X coord of the point on the image (0-100%)
                                        pointY: pointY_percent, // Y coord of the point on the image (0-100%)
                                    });
                                }
                            });
                        }
                    });
                });
                console.log("All annotations processed. Total annotations:", allAnnotations.length); 
                annotationsLoaded = true; 

            } catch (e) {
                console.error("Critical error during annotation loading or processing:", e); 
                alert("A critical error occurred while loading annotations: " + e.message + ". Check console for network/parsing details."); 
                annotationsLoaded = false; 
            } finally {
                loadingOverlay.classList.add('hidden'); 
            }
            updateSlice(); 
        }

        // --- Image Preloading ---
        function preloadAllImages() {
            console.log("Preloading images initiated.");
            for (let i = 1; i <= imageCount; i++) {
                const img = new Image();
                img.src = `${imageFolderPath}${imageBaseName}${i}${imageExtension}`;
                preloadedImages.push(img); 
            }
        }

        // --- Display Logic ---
        function updateSlice() {
            const currentSlice = parseInt(sliceSlider.value); 
            const imageUrl = `${imageFolderPath}${imageBaseName}${currentSlice}${imageExtension}`; 
            
            if (brainSliceImage.src !== new URL(imageUrl, window.location.href).href) {
                brainSliceImage.src = imageUrl;
            }

            sliceNumberDisplay.textContent = `Slice: ${currentSlice} / ${imageCount}`;

            // Clear previous SVG elements
            annotationSvgOverlay.innerHTML = ''; 
            // Clear previous labels from side panels
            leftAnnotationPanel.innerHTML = ''; 
            rightAnnotationPanel.innerHTML = '';

            // Reset for new slice's stacking logic. Store {top, bottom, height} for each placed label.
            let placedLabelsLeft = [];
            let placedLabelsRight = [];

            // This ensures annotations are drawn only after the image is fully loaded and sized
            brainSliceImage.onload = function() {
                // Ensure this onload only fires once per image load
                this.onload = null; 

                // Get dynamic dimensions of the image wrapper (which is where SVG coordinates are relative to)
                const imageWidth = brainSliceImage.offsetWidth;
                const imageHeight = brainSliceImage.offsetHeight;
                
                // Get the *current* bounding client rect for the image wrapper and panels
                // These are viewport-relative coordinates needed for connecting lines correctly.
                const imageWrapperRect = brainSliceImage.parentElement.getBoundingClientRect();
                const leftPanelRect = leftAnnotationPanel.getBoundingClientRect();
                const rightPanelRect = rightAnnotationPanel.getBoundingClientRect();

                if (annotationsLoaded) {
                    // Sort annotations by their Y-coordinate for consistent stacking
                    const annotationsForCurrentSlice = allAnnotations.filter(ann => ann.slice === currentSlice)
                                                                     .sort((a, b) => a.pointY - b.pointY);

                    annotationsForCurrentSlice.forEach((annotation, index) => {
                        const pX_px_image = (annotation.pointX / 100) * imageWidth; // Point X in pixels relative to image
                        const pY_px_image = (annotation.pointY / 100) * imageHeight; // Point Y in pixels relative to image

                        // --- Create HTML Label div ---
                        const labelDiv = document.createElement('div');
                        labelDiv.classList.add('annotation-label');
                        labelDiv.textContent = annotation.text;
                        labelDiv.id = `label-${currentSlice}-${index}`;
                        
                        let targetPanel;
                        let placedLabelsArray; // Which stacking array to use (left or right panel)
                        let isLeftPanel;

                        // Determine which side panel the label should go into
                        if (pX_px_image < imageWidth / 2) { // If point is on the left half of the image
                            targetPanel = leftAnnotationPanel;
                            placedLabelsArray = placedLabelsLeft;
                            isLeftPanel = true;
                        } else { // If point is on the right half of the image
                            targetPanel = rightAnnotationPanel;
                            placedLabelsArray = placedLabelsRight;
                            isLeftPanel = false;
                        }
                        
                        // Append to the correct panel temporarily to measure its actual dimensions
                        targetPanel.appendChild(labelDiv); 
                        const labelHeight = labelDiv.offsetHeight;

                        // --- Vertical Stacking Logic within the panel ---
                        // Calculate desired Y position within the panel, proportional to point's Y on image
                        // Initial Y is center of the label
                        let desiredLabelY_panel_px = (annotation.pointY / 100) * targetPanel.offsetHeight; 

                        // Ensure label doesn't go off the top edge of the panel
                        desiredLabelY_panel_px = Math.max(desiredLabelY_panel_px, labelHeight / 2 + LABEL_PANEL_PADDING);

                        // Check for overlaps with already placed labels in this specific panel
                        for (let i = 0; i < placedLabelsArray.length; i++) {
                            const existingLabel = placedLabelsArray[i];
                            // Check if the current label's potential top collides with an existing label's bottom
                            if (desiredLabelY_panel_px - (labelHeight / 2) < existingLabel.bottom + LABEL_SPACING) {
                                // Overlap detected. Adjust current label's Y to be below the existing one.
                                desiredLabelY_panel_px = existingLabel.bottom + LABEL_SPACING + (labelHeight / 2);
                            }
                        }

                        // Ensure label doesn't go off the bottom edge of the panel
                        desiredLabelY_panel_px = Math.min(desiredLabelY_panel_px, targetPanel.offsetHeight - (labelHeight / 2) - LABEL_PANEL_PADDING);


                        // Apply the final vertical position (relative to panel's top-left)
                        labelDiv.style.top = `${desiredLabelY_panel_px}px`;
                        
                        // Horizontal positioning within the panel
                        if (isLeftPanel) {
                            labelDiv.style.left = `${LABEL_PANEL_PADDING}px`; 
                        } else {
                            labelDiv.style.right = `${LABEL_PANEL_PADDING}px`; 
                        }

                        // Store this label's final actual (top, bottom) positions for future overlap checks
                        placedLabelsArray.push({
                            top: desiredLabelY_panel_px - (labelHeight / 2), // Actual top edge of the label
                            bottom: desiredLabelY_panel_px + (labelHeight / 2), // Actual bottom edge of the label
                            height: labelHeight,
                            element: labelDiv 
                        });

                        // --- Create SVG Line (slanted) ---
                        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        
                        // Line starts at the point (relative to image-wrapper)
                        line.setAttribute('x1', pX_px_image);
                        line.setAttribute('y1', pY_px_image);
                        
                        // Line's mid-point at the image edge (no offset to image itself)
                        let lineMidX_px;
                        if (isLeftPanel) {
                            lineMidX_px = 0; // Left edge of image-wrapper
                        } else {
                            lineMidX_px = imageWidth; // Right edge of image-wrapper
                        }

                        // Line's end-point connects to the label in the panel
                        // We need to convert the label's Y-position (relative to panel)
                        // to the image-wrapper's coordinate system.
                        // labelDiv.offsetTop is relative to its immediate parent (the panel).
                        // panelRect.top is the panel's top relative to the viewport.
                        // imageWrapperRect.top is the image-wrapper's top relative to the viewport.
                        // So, labelY_in_image_coords = (label.offsetTop + panel.top) - imageWrapper.top
                        const labelY_in_image_coords = (labelDiv.offsetTop + targetPanel.getBoundingClientRect().top) - imageWrapperRect.top;

                        line.setAttribute('x2', lineMidX_px); // Line ends at the image edge
                        line.setAttribute('y2', labelY_in_image_coords); // Line ends at label's vertical center on image edge

                        line.id = `line-${currentSlice}-${index}`;
                        annotationSvgOverlay.appendChild(line);

                        // Create SVG Circle for the point (always visible)
                        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        circle.setAttribute('cx', pX_px_image);
                        circle.setAttribute('cy', pY_px_image);
                        circle.setAttribute('r', 4); 
                        circle.classList.add('show'); 
                        circle.id = `circle-${currentSlice}-${index}`; 
                        annotationSvgOverlay.appendChild(circle);

                        // --- Add Hover Interactivity ---
                        // IMPORTANT: Add 'pointer-events: auto' to labels for hover to work
                        labelDiv.style.pointerEvents = 'auto'; 

                        labelDiv.addEventListener('mouseover', () => {
                            document.getElementById(`line-${currentSlice}-${index}`)?.classList.add('visible-on-hover');
                            document.getElementById(`circle-${currentSlice}-${index}`)?.classList.add('visible-on-hover-circle');
                        });
                        labelDiv.addEventListener('mouseout', () => {
                            document.getElementById(`line-${currentSlice}-${index}`)?.classList.remove('visible-on-hover');
                            document.getElementById(`circle-${currentSlice}-${index}`)?.classList.remove('visible-on-hover-circle');
                        });
                        // --- End Hover Interactivity ---

                        setTimeout(() => labelDiv.classList.add('show'), 10);
                    });
                } else {
                    console.warn("Annotations not yet loaded or failed to load. Skipping rendering of annotations for this slice.");
                }
            };

            // If the image is already loaded (from cache or preloading), trigger the onload manually
            if (brainSliceImage.complete) {
                brainSliceImage.onload(); 
            }
        }

        // --- Initial Setup ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM content loaded. Initializing viewer."); 
            preloadAllImages(); 
            loadAnnotations(); 
        });

        sliceSlider.addEventListener('change', updateSlice); 
        
        // Debounced resize event listener
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                console.log("Window resized, updating slice.");
                updateSlice();
            }, 100); 
        });
    </script>
</body>
</html>
