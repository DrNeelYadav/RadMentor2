<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Brain MRI Viewer - RadMentor</title>
    <link href="https://fonts.googleapis.com/css2?family=Rubik:wght@300;400;500;700&display=swap" rel="stylesheet"/>
    <style>
        /* Base styles for all themes */
        body {
            font-family: 'Rubik', sans-serif;
            margin: 0;
            transition: background-color 0.3s ease, color 0.3s ease;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: var(--bg-color);
            color: var(--text-color);
            flex-direction: column; /* Arrange items vertically */
            overflow: hidden; /* Prevent body scroll if content overflows slightly */
        }

        /* Light Theme Variables */
        body.light-theme {
            --bg-color: #f0f8ff; /* Very light blue/off-white background */
            --container-bg-color: #ffffff; /* Pure white container background */
            --text-color: #333333; /* Dark grey for general text */
            --heading-color: #0d47a1; /* Darker blue for headings */
            --box-bg-color: #e3f2fd; /* Light blue for boxes */
            --box-hover-bg-color: #bbdefb; /* Slightly darker light blue on hover */
            --box-border-color: #90caf9; /* Medium blue for box borders */
            --back-button-bg: #1e88e5; /* Standard blue button */
            --back-button-hover-bg: #1565c0; /* Darker blue button on hover */
            --slider-track-bg: #c5d9e8; /* Light blue for slider track */
            --slider-thumb-bg: #1e88e5; /* Blue for slider thumb */
            --annotation-text-color: #1a237e; /* Darker blue for annotation text */
            --annotation-bg-color: rgba(255, 255, 255, 0.95); /* More opaque white background */
            --annotation-border-color: #64b5f6; /* Light blue border */
            --annotation-line-color: #42a5f5; /* Medium blue for lines */
            --annotation-point-color: #f44336; /* Red dot for point */
        }

        /* Dark Theme Variables */
        body:not(.light-theme) {
            --bg-color: #004d5e;
            --container-bg-color: #043f4e;
            --text-color: #ffffff;
            --heading-color: #ffffff;
            --box-bg-color: #095a71;
            --box-hover-bg-color: #064a5c;
            --box-border-color: #043f4e;
            --back-button-bg: #00bcd4;
            --back-button-hover-bg: #0097a7;
            --slider-track-bg: #032b36; /* Darker track for dark theme */
            --slider-thumb-bg: #00bcd4; /* Brighter thumb for dark theme */
            --annotation-text-color: #e0f2f1; /* Light text for annotations */
            --annotation-bg-color: rgba(0, 0, 0, 0.85); /* More opaque black background */
            --annotation-border-color: #00bcd4; /* Accent color border */
            --annotation-line-color: #00bcd4; /* Accent color for lines */
            --annotation-point-color: #f44336; /* Red dot for point */
        }

        .viewer-container {
            background-color: var(--container-bg-color);
            border-radius: 12px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
            padding: 20px;
            margin: 20px auto;
            max-width: 800px; /* Wider to accommodate labels */
            width: 90%; /* Responsive width */
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: center; /* Center items horizontally */
        }

        .viewer-container h1 {
            color: var(--heading-color);
            font-size: 2.2rem;
            margin-bottom: 20px;
            text-align: center;
        }

        /* Canvas styling */
        #anatomyCanvas {
            display: block; /* Remove extra space below canvas */
            background-color: #000; /* Black background for imaging studies */
            border-radius: 8px;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.5);
            /* Important for responsiveness: max-width and height */
            max-width: 100%;
            height: auto; /* Maintain aspect ratio */
        }

        .controls {
            width: 100%;
            margin-top: 25px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        #sliceSlider {
            width: 90%;
            -webkit-appearance: none;
            appearance: none;
            height: 8px;
            background: var(--slider-track-bg);
            outline: none;
            opacity: 0.9;
            transition: opacity .2s;
            border-radius: 5px;
        }

        #sliceSlider:hover {
            opacity: 1;
        }

        #sliceSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--slider-thumb-bg);
            cursor: grab;
            box-shadow: 0 0 5px rgba(0,0,0,0.3);
        }

        #sliceSlider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--slider-thumb-bg);
            cursor: grab;
            box-shadow: 0 0 5px rgba(0,0,0,0.3);
        }

        #sliceNumberDisplay {
            font-size: 1.1rem;
            color: var(--text-color);
            font-weight: 500;
        }

        .back-button {
            display: block;
            width: 200px;
            margin: 40px auto 0;
            padding: 15px 25px;
            background-color: var(--back-button-bg);
            color: white;
            text-align: center;
            border-radius: 5px;
            text-decoration: none;
            font-weight: bold;
            font-size: 1.1rem;
            transition: background-color 0.3s ease;
        }
        .back-button:hover {
            background-color: var(--back-button-hover-bg);
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .viewer-container {
                padding: 15px;
                width: 95%;
            }
            h1 {
                font-size: 2rem;
            }
        }
        @media (max-width: 480px) {
            h1 {
                font-size: 1.8rem;
            }
            .back-button {
                width: 100%;
                font-size: 1rem;
            }
        }
        /* Loading spinner CSS */
        .loading-overlay {
            position: absolute; /* Changed to absolute for proper overlay on canvas */
            top: 0;
            left: 0;
            width: 100%; /* Take full width of parent image-wrapper */
            height: 100%; /* Take full height of parent image-wrapper */
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            z-index: 100; /* On top of everything */
            transition: opacity 0.3s ease;
            opacity: 1;
        }
        .loading-overlay.hidden {
            opacity: 0;
            pointer-events: none; /* Allow clicks through when hidden */
        }
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #fff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="viewer-container">
        <h1>Axial Brain Anatomy</h1>

        <div class="image-wrapper">
            <canvas id="anatomyCanvas"></canvas> 
            <div class="loading-overlay" id="loadingOverlay">
                <div class="spinner"></div>&nbsp;Loading Annotations...
            </div>
        </div>

        <div class="controls">
            <input type="range" id="sliceSlider" min="1" max="24" value="1">
            <div id="sliceNumberDisplay">Slice: 1 / 24</div>
        </div>

        <a href="../../index.html" class="back-button">Back to MRI Anatomy</a>
    </div>

    <script>
        const imageCount = 24; // Total number of brain images
        const imageBaseName = 'brain'; // Filenames are brain1.png, brain2.png...
        const imageExtension = '.png'; // Confirmed as .png
        const imageFolderPath = './Images/'; // Correct path to your Images subfolder

        const annotationJsonPath = './annotations/'; // Path to your annotations folder
        const imageDimensionMM = 512; // Your images are 512x512 pixels, representing 512x512 mm FOV

        // --- Canvas Elements ---
        const anatomyCanvas = document.getElementById('anatomyCanvas');
        const ctx = anatomyCanvas.getContext('2d');
        const imageWrapper = anatomyCanvas.parentElement; // Get parent div for dimensions

        const sliceSlider = document.getElementById('sliceSlider');
        const sliceNumberDisplay = document.getElementById('sliceNumberDisplay');
        const loadingOverlay = document.getElementById('loadingOverlay');

        let allAnnotations = []; // All processed annotations
        let annotationsLoaded = false; // Flag to track if annotations are loaded
        const preloadedImages = []; // Array to store preloaded Image objects

        // --- THEME LOGIC (standard) ---
        function setTheme(theme) {
            if (theme === 'light') {
                document.body.classList.add('light-theme');
                localStorage.setItem('theme', 'light');
            } else {
                document.body.classList.remove('light-theme');
                localStorage.setItem('theme', 'dark');
            }
        }

        function setInitialTheme() {
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme === 'light') {
                document.body.classList.add('light-theme');
            } else {
                document.body.classList.remove('light-theme');
            }
        }
        setInitialTheme();
        // --- END THEME LOGIC ---

        // --- JSON FILENAMES (CRITICAL: THIS LIST MUST BE EXACT) ---
        const jsonFilenames = [
            "Angular Gyrus.json", "Aqueduct.json", "Caudate Nucleus.json", "Central Lobule.json",
            "Cerebellar Nuclei.json", "Cerebellar Peduncles.json", "Culmen.json", "Cuneus.json",
            "Declive.json", "Flocculus.json", "Fornix.json", "Frontal horn of LV.json",
            "Globus Pallidus.json", "Inferior Frontal Gyrus.json", "Internal Capsule.json",
            "Interpeduncular cistern.json", "Lateral Occipitotemporal gyrus.json",
            "Maxillary Sinus.json", "Medial Frontal Gyrus.json", "Medulla Oblongata.json",
            "Mesencephalic cistern.json", "Midbrain.json", "Middle Frontal Gyrus.json",
            "Olfactory Sulcus.json", // Corrected name
            "Optic Nerve.json", "Peduncles.json", "Pons.json", "Post Central Gyrus.json",
            "Posterior horn of LV.json", "Pre Central Gyrus.json", "Precuneus.json", "Putamen.json",
            "Septum Pellucidum.json", "Straight Gyrus.json", "Superior Frontal Gyrus.json",
            "Superior Parietal Lobule.json", "Suprachiasmatic cistern.json", "Supramarginal Gyrus.json",
            "Thallamus.json" // Assume correct, else change to Thalamus.json
        ];
        // --- END JSON FILENAMES ---

        // --- Data Loading and Processing ---
        async function loadAnnotations() {
            console.log("Loading annotations started.");
            loadingOverlay.classList.remove('hidden'); // Show loading overlay

            try {
                const fetchPromises = jsonFilenames.map(filename =>
                    fetch(`${annotationJsonPath}${filename}`)
                        .then(response => {
                            if (!response.ok) {
                                throw new Error(`Failed to load ${filename}: ${response.statusText} (URL: ${response.url})`);
                            }
                            return response.json();
                        })
                        .catch(error => {
                            console.error(`Error fetching or parsing ${filename}:`, error);
                            // Re-throw to ensure Promise.all catches it and `finally` block runs
                            throw error; 
                        })
                );

                const results = await Promise.all(fetchPromises);
                console.log("All JSON fetches completed.", results); 

                results.forEach(jsonData => {
                    if (!jsonData) { 
                        return; // Skip if fetch failed
                    }
                    if (!jsonData.markups || !Array.isArray(jsonData.markups)) {
                        console.warn("Skipping invalid or empty JSON data for a markup file (missing 'markups' array).", jsonData);
                        return;
                    }

                    jsonData.markups.forEach(markup => {
                        if (markup.type === "Fiducial" && Array.isArray(markup.controlPoints)) {
                            markup.controlPoints.forEach(cp => {
                                if (cp.position && cp.position.length === 3) {
                                    const sliceZ = cp.position[2]; 
                                    const imageSliceNumber = Math.round(sliceZ); 

                                    // Convert Slicer's mm coordinates to percentages for 512x512 image
                                    const pointX_percent = (cp.position[0] / imageDimensionMM) * 100;
                                    const pointY_percent = (cp.position[1] / imageDimensionMM) * 100;

                                    const cleanLabelText = cp.label.split(/-\d+/)[0].trim();

                                    // Initial guess for label position (percentages). Fine-tune these visually.
                                    const defaultLabelX = pointX_percent + 5; 
                                    const defaultLabelY = pointY_percent - 5; 

                                    allAnnotations.push({
                                        slice: imageSliceNumber,
                                        text: cleanLabelText,
                                        pointX: pointX_percent,
                                        pointY: pointY_percent,
                                        labelX: defaultLabelX, 
                                        labelY: defaultLabelY  
                                    });
                                }
                            });
                        }
                    });
                });
                console.log("All annotations processed. Total:", allAnnotations.length); 
                annotationsLoaded = true; 

            } catch (e) {
                console.error("Critical error during annotation loading or processing:", e); 
                alert("A critical error occurred while loading annotations: " + e.message + ". Check console for details.");
                annotationsLoaded = false;
            } finally {
                loadingOverlay.classList.add('hidden'); // Hide loading overlay regardless of success/fail
            }

            // Always attempt to updateSlice even if annotations failed to load, to show the image
            updateSlice();
        }

        // --- Image Preloading ---
        // Load all images into Image objects for smoother canvas drawing
        const imagesCache = {};
        function preloadAllImages() {
            for (let i = 1; i <= imageCount; i++) {
                const img = new Image();
                img.src = `${imageFolderPath}${imageBaseName}${i}${imageExtension}`;
                imagesCache[i] = img; // Store Image object in cache
            }
            console.log("Preloading images initiated and stored in cache.");
        }


        // --- Canvas Drawing Logic ---
        function drawCurrentSlice() {
            const currentSlice = parseInt(sliceSlider.value);
            const imageToDraw = imagesCache[currentSlice];

            if (imageToDraw && imageToDraw.complete) {
                // Resize canvas to match image wrapper's current size for responsiveness
                anatomyCanvas.width = imageWrapper.clientWidth;
                anatomyCanvas.height = imageWrapper.clientHeight;

                // Draw image, scaled to fit canvas while maintaining aspect ratio
                const scale = Math.min(anatomyCanvas.width / imageToDraw.naturalWidth, anatomyCanvas.height / imageToDraw.naturalHeight);
                const scaledWidth = imageToDraw.naturalWidth * scale;
                const scaledHeight = imageToDraw.naturalHeight * scale;
                const offsetX = (anatomyCanvas.width - scaledWidth) / 2;
                const offsetY = (anatomyCanvas.height - scaledHeight) / 2;

                ctx.clearRect(0, 0, anatomyCanvas.width, anatomyCanvas.height); // Clear previous drawing
                ctx.drawImage(imageToDraw, offsetX, offsetY, scaledWidth, scaledHeight);

                // Draw Annotations
                if (annotationsLoaded) {
                    allAnnotations.filter(ann => ann.slice === currentSlice).forEach(annotation => {
                        // Convert percentage coordinates (from 0-100% of original 512x512)
                        // to pixel coordinates on the *scaled and offset* canvas image
                        const pixelPointX = (annotation.pointX / 100) * scaledWidth + offsetX;
                        const pixelPointY = (annotation.pointY / 100) * scaledHeight + offsetY;

                        const pixelLabelX = (annotation.labelX / 100) * scaledWidth + offsetX;
                        const pixelLabelY = (annotation.labelY / 100) * scaledHeight + offsetY;

                        // Draw Line
                        ctx.beginPath();
                        ctx.moveTo(pixelPointX, pixelPointY);
                        ctx.lineTo(pixelLabelX, pixelLabelY);
                        ctx.strokeStyle = getComputedStyle(document.body).getPropertyValue('--annotation-line-color').trim(); // Get CSS variable
                        ctx.lineWidth = 2;
                        ctx.stroke();

                        // Draw Point
                        ctx.beginPath();
                        ctx.arc(pixelPointX, pixelPointY, 4, 0, Math.PI * 2); // Radius 4
                        ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--annotation-point-color').trim(); // Get CSS variable
                        ctx.fill();

                        // Draw Text Label
                        ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--annotation-text-color').trim();
                        ctx.font = '500 14px Rubik'; // Matching your annotation-label font-size and weight
                        ctx.textBaseline = 'middle'; // Vertically center text on Y coordinate
                        ctx.textAlign = 'center';   // Horizontally center text on X coordinate

                        // Draw a background rectangle for the text
                        const textMetrics = ctx.measureText(annotation.text);
                        const textWidth = textMetrics.width;
                        const textHeight = parseInt(ctx.font.match(/\d+/)) * 1.5; // Approximate height based on font size

                        const bgPaddingX = 5;
                        const bgPaddingY = 3;

                        ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--annotation-bg-color').trim();
                        ctx.roundRect(
                            pixelLabelX - textWidth / 2 - bgPaddingX,
                            pixelLabelY - textHeight / 2 - bgPaddingY,
                            textWidth + bgPaddingX * 2,
                            textHeight + bgPaddingY * 2,
                            4 // border radius
                        );
                        ctx.fill();

                        // Draw border for the background rectangle
                        ctx.strokeStyle = getComputedStyle(document.body).getPropertyValue('--annotation-border-color').trim();
                        ctx.lineWidth = 1;
                        ctx.stroke();


                        ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--annotation-text-color').trim(); // Reset fill style for text
                        ctx.fillText(annotation.text, pixelLabelX, pixelLabelY);
                    });
                } else {
                    console.warn("Annotations not yet loaded or failed to load. Skipping rendering of annotations for this slice.");
                }
            } else {
                // If image is not yet loaded, try again when it loads
                console.log("Image not yet complete for slice", currentSlice, ". Will retry on image load.");
            }
        }

        // --- Main Update Function (called on slider change or load) ---
        function updateSlice() {
            const currentSlice = parseInt(sliceSlider.value);
            sliceNumberDisplay.textContent = `Slice: ${currentSlice} / ${imageCount}`;

            // Load and draw image (or draw from cache if already loaded)
            const imageToLoad = imagesCache[currentSlice];
            if (imageToLoad) {
                if (imageToLoad.complete) {
                    drawCurrentSlice();
                } else {
                    // If image is not yet loaded, set its onload to draw
                    imageToLoad.onload = drawCurrentSlice;
                }
            } else {
                console.error("Image not found in cache for slice:", currentSlice);
            }
        }

        // --- Initial Setup ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM content loaded."); 
            preloadAllImages(); // Start preloading all images

            // Set up initial canvas size based on wrapper
            anatomyCanvas.width = imageWrapper.clientWidth;
            anatomyCanvas.height = imageWrapper.clientHeight;
            
            // Resize canvas on window resize to keep it responsive
            window.addEventListener('resize', () => {
                anatomyCanvas.width = imageWrapper.clientWidth;
                anatomyCanvas.height = imageWrapper.clientHeight;
                updateSlice(); // Redraw content to fit new size
            });

            loadAnnotations(); // Start loading JSON data and call updateSlice when done
            // The first updateSlice will be called by loadAnnotations() or by image.onload
        });

        sliceSlider.addEventListener('input', updateSlice);
    </script>
</body>
</html>
