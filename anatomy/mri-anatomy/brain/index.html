<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Brain MRI Viewer - RadMentor</title>
    <link href="https://fonts.googleapis.com/css2?family=Rubik:wght@300;400;500;700&display=swap" rel="stylesheet"/>
    <style>
        /* Base styles for all themes */
        body {
            font-family: 'Rubik', sans-serif;
            margin: 0;
            transition: background-color 0.3s ease, color 0.3s ease;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: var(--bg-color);
            color: var(--text-color);
            flex-direction: column; /* Arrange items vertically */
            overflow: hidden; /* Prevent body scroll if content overflows slightly */
        }

        /* Light Theme Variables */
        body.light-theme {
            --bg-color: #f0f8ff; /* Very light blue/off-white background */
            --container-bg-color: #ffffff; /* Pure white container background */
            --text-color: #333333; /* Dark grey for general text */
            --heading-color: #0d47a1; /* Darker blue for headings */
            --box-bg-color: #e3f2fd; /* Light blue for boxes */
            --box-hover-bg-color: #bbdefb; /* Slightly darker light blue on hover */
            --box-border-color: #90caf9; /* Medium blue for box borders */
            --back-button-bg: #1e88e5; /* Standard blue button */
            --back-button-hover-bg: #1565c0; /* Darker blue button on hover */
            --slider-track-bg: #c5d9e8; /* Light blue for slider track */
            --slider-thumb-bg: #1e88e5; /* Blue for slider thumb */
            --annotation-text-color: #1a237e; /* Darker blue for annotation text */
            --annotation-bg-color: rgba(255, 255, 255, 0.95); /* More opaque white background */
            --annotation-border-color: #64b5f6; /* Light blue border */
            --annotation-line-color: #42a5f5; /* Medium blue for lines */
            --annotation-point-color: #f44336; /* Red dot for point */
        }

        /* Dark Theme Variables */
        body:not(.light-theme) {
            --bg-color: #004d5e;
            --container-bg-color: #043f4e;
            --text-color: #ffffff;
            --heading-color: #ffffff;
            --box-bg-color: #095a71;
            --box-hover-bg-color: #064a5c;
            --box-border-color: #043f4e;
            --back-button-bg: #00bcd4;
            --back-button-hover-bg: #0097a7;
            --slider-track-bg: #032b36; /* Darker track for dark theme */
            --slider-thumb-bg: #00bcd4; /* Brighter thumb for dark theme */
            --annotation-text-color: #e0f2f1; /* Light text for annotations */
            --annotation-bg-color: rgba(0, 0, 0, 0.85); /* More opaque black background */
            --annotation-border-color: #00bcd4; /* Accent color border */
            --annotation-line-color: #00bcd4; /* Accent color for lines */
            --annotation-point-color: #f44336; /* Red dot for point */
        }

        .viewer-container {
            background-color: var(--container-bg-color);
            border-radius: 12px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
            padding: 20px;
            margin: 20px auto;
            max-width: 800px; /* Wider to accommodate labels */
            width: 90%; /* Responsive width */
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: center; /* Center items horizontally */
        }

        .viewer-container h1 {
            color: var(--heading-color);
            font-size: 2.2rem;
            margin-bottom: 20px;
            text-align: center;
        }

        /* Canvas styling */
        #anatomyCanvas {
            display: block; /* Remove extra space below canvas */
            background-color: #000; /* Black background for imaging studies */
            border-radius: 8px;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.5);
            max-width: 100%;
            height: auto; /* Maintain aspect ratio */
        }

        .controls {
            width: 100%;
            margin-top: 25px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        #sliceSlider {
            width: 90%;
            -webkit-appearance: none;
            appearance: none;
            height: 8px;
            background: var(--slider-track-bg);
            outline: none;
            opacity: 0.9;
            transition: opacity .2s;
            border-radius: 5px;
        }

        #sliceSlider:hover {
            opacity: 1;
        }

        #sliceSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--slider-thumb-bg);
            cursor: grab;
            box-shadow: 0 0 5px rgba(0,0,0,0.3);
        }

        #sliceSlider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--slider-thumb-bg);
            cursor: grab;
            box-shadow: 0 0 5px rgba(0,0,0,0.3);
        }

        #sliceNumberDisplay {
            font-size: 1.1rem;
            color: var(--text-color);
            font-weight: 500;
        }

        .back-button {
            display: block;
            width: 200px;
            margin: 40px auto 0;
            padding: 15px 25px;
            background-color: var(--back-button-bg);
            color: white;
            text-align: center;
            border-radius: 5px;
            text-decoration: none;
            font-weight: bold;
            font-size: 1.1rem;
            transition: background-color 0.3s ease;
        }
        .back-button:hover {
            background-color: var(--back-button-hover-bg);
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .viewer-container {
                padding: 15px;
                width: 95%;
            }
            h1 {
                font-size: 2rem;
            }
        }
        @media (max-width: 480px) {
            h1 {
                font-size: 1.8rem;
            }
            .back-button {
                width: 100%;
                font-size: 1rem;
            }
        }
        /* Loading overlay CSS - Ensure it hides completely */
        .loading-overlay {
            position: fixed; /* Fixed to cover the entire viewport */
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.85); /* Slightly darker to ensure visibility */
            color: white;
            display: flex;
            flex-direction: column; /* Stack spinner and text */
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            z-index: 1000; /* Extremely high z-index to always be on top */
            transition: opacity 0.5s ease; /* Slower transition for effect */
            opacity: 1;
            pointer-events: auto; /* Block interaction when visible */
        }
        .loading-overlay.hidden {
            opacity: 0;
            pointer-events: none; /* Crucial: allows clicks through when hidden */
        }
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #fff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin-bottom: 10px; /* Space between spinner and text */
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="viewer-container">
        <h1>Axial Brain Anatomy</h1>

        <div class="image-wrapper">
            <canvas id="anatomyCanvas"></canvas> 
            <div class="loading-overlay" id="loadingOverlay">
                <div class="spinner"></div>&nbsp;Loading Annotations...
            </div>
        </div>

        <div class="controls">
            <input type="range" id="sliceSlider" min="1" max="24" value="1">
            <div id="sliceNumberDisplay">Slice: 1 / 24</div>
        </div>

        <a href="../../index.html" class="back-button">Back to MRI Anatomy</a>
    </div>

    <script>
        const imageCount = 24;
        const imageBaseName = 'brain'; 
        const imageExtension = '.png'; 
        const imageFolderPath = './Images/'; 

        const annotationJsonPath = './annotations/'; 
        const imageDimensionMM = 512; 

        // --- Canvas Elements ---
        const anatomyCanvas = document.getElementById('anatomyCanvas');
        const ctx = anatomyCanvas.getContext('2d');
        const imageWrapper = anatomyCanvas.parentElement; // Get parent div for dimensions

        const sliceSlider = document.getElementById('sliceSlider');
        const sliceNumberDisplay = document.getElementById('sliceNumberDisplay');
        const loadingOverlay = document.getElementById('loadingOverlay'); // New loading overlay element

        let allAnnotations = []; 
        let annotationsLoaded = false; 
        const imagesCache = {}; // Cache for preloaded Image objects

        // --- THEME LOGIC (standard) ---
        function setTheme(theme) {
            if (theme === 'light') {
                document.body.classList.add('light-theme');
                localStorage.setItem('theme', 'light');
            } else {
                document.body.classList.remove('light-theme');
                localStorage.setItem('theme', 'dark');
            }
        }

        function setInitialTheme() {
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme === 'light') {
                document.body.classList.add('light-theme');
            } else {
                document.body.classList.remove('light-theme');
            }
        }
        setInitialTheme();
        // --- END THEME LOGIC ---

        // --- JSON FILENAMES (CRITICAL: THIS LIST MUST BE EXACT) ---
        // Corrected "Olfatory Sulcus.json" to "Olfactory Sulcus.json"
        const jsonFilenames = [
            "Angular Gyrus.json", "Aqueduct.json", "Caudate Nucleus.json", "Central Lobule.json",
            "Cerebellar Nuclei.json", "Cerebellar Peduncles.json", "Culmen.json", "Cuneus.json",
            "Declive.json", "Flocculus.json", "Fornix.json", "Frontal horn of LV.json",
            "Globus Pallidus.json", "Inferior Frontal Gyrus.json", "Internal Capsule.json",
            "Interpeduncular cistern.json", "Lateral Occipitotemporal gyrus.json",
            "Maxillary Sinus.json", 
            "Medial Frontal Gyrus.json",
            "Medulla Oblongata.json",
            "Mesencephalic cistern.json",
            "Midbrain.json",
            "Middle Frontal Gyrus.json",
            "Olfactory Sulcus.json", // Corrected name
            "Optic Nerve.json", "Peduncles.json", "Pons.json", "Post Central Gyrus.json",
            "Posterior horn of LV.json", "Pre Central Gyrus.json", "Precuneus.json", "Putamen.json",
            "Septum Pellucidum.json", "Straight Gyrus.json", "Superior Frontal Gyrus.json",
            "Superior Parietal Lobule.json", "Suprachiasmatic cistern.json", "Supramarginal Gyrus.json",
            "Thallamus.json" // Assuming this is correct, otherwise change to "Thalamus.json"
        ];
        // --- END JSON FILENAMES ---

        // --- Data Loading and Processing ---
        async function loadAnnotations() {
            console.log("Loading annotations started.");
            loadingOverlay.classList.remove('hidden'); // Show loading overlay

            try {
                const fetchPromises = jsonFilenames.map(filename =>
                    fetch(`${annotationJsonPath}${filename}`)
                        .then(response => {
                            console.log(`Fetched ${filename}. Status: ${response.status}`);
                            if (!response.ok) {
                                throw new Error(`Failed to load ${filename}: ${response.statusText} (URL: ${response.url})`);
                            }
                            return response.json();
                        })
                        .catch(error => {
                            console.error(`Error fetching or parsing ${filename}:`, error);
                            // Re-throw to ensure Promise.all fails if any fetch fails
                            throw error; 
                        })
                );

                const results = await Promise.all(fetchPromises);
                console.log("All JSON fetches completed.", results); 

                results.forEach(jsonData => {
                    if (!jsonData) { 
                        return; // Skip if fetch failed
                    }
                    if (!jsonData.markups || !Array.isArray(jsonData.markups)) {
                        console.warn("Skipping invalid or empty JSON data for a markup file (missing 'markups' array).", jsonData);
                        return;
                    }

                    jsonData.markups.forEach(markup => {
                        if (markup.type === "Fiducial" && Array.isArray(markup.controlPoints)) {
                            markup.controlPoints.forEach(cp => {
                                if (cp.position && cp.position.length === 3) {
                                    const sliceZ = cp.position[2]; 
                                    const imageSliceNumber = Math.round(sliceZ); // Directly use rounded Z as slice number

                                    const pointX_percent = (cp.position[0] / imageDimensionMM) * 100;
                                    const pointY_percent = (cp.position[1] / imageDimensionMM) * 100;

                                    const cleanLabelText = cp.label.split(/-\d+/)[0].trim();

                                    // Initial guess for label position (percentages). Fine-tune these visually.
                                    const defaultLabelX = pointX_percent + 5; 
                                    const defaultLabelY = pointY_percent - 5; 

                                    allAnnotations.push({
                                        slice: imageSliceNumber,
                                        text: cleanLabelText,
                                        pointX: pointX_percent,
                                        pointY: pointY_percent,
                                        labelX: defaultLabelX, 
                                        labelY: defaultLabelY  
                                    });
                                }
                            });
                        }
                    });
                });
                console.log("All annotations processed. Total annotations:", allAnnotations.length); 
                annotationsLoaded = true; // Set flag to true

            } catch (e) {
                console.error("Critical error during annotation loading or processing:", e); 
                alert("A critical error occurred while loading annotations: " + e.message + ". Check console for details."); 
                annotationsLoaded = false; // Ensure flag is false if error
            } finally {
                // Ensure the loading overlay is hidden ONLY after its class list operations complete.
                // Adding a slight delay might help ensure it's removed AFTER it's rendered properly.
                setTimeout(() => {
                    loadingOverlay.classList.add('hidden'); // Hide loading overlay regardless of success/fail
                }, 500); // 0.5 second delay
            }

            // Always attempt to updateSlice even if annotations failed to load, to show the image
            updateSlice();
        }

        // --- Canvas Drawing Logic ---
        function drawCurrentSlice() {
            const currentSlice = parseInt(sliceSlider.value);
            const imageToDraw = imagesCache[currentSlice];

            // If the image is not yet loaded or not found in cache, draw black and log
            if (!imageToDraw || !imageToDraw.complete) {
                ctx.clearRect(0, 0, anatomyCanvas.width, anatomyCanvas.height);
                ctx.fillStyle = "#000"; // Black background if image not ready
                ctx.fillRect(0, 0, anatomyCanvas.width, anatomyCanvas.height);
                console.warn(`Image brain${currentSlice}.png not yet loaded or found. Skipping drawing for this slice.`);
                return;
            }

            // Resize canvas to match image wrapper's current size for responsiveness
            anatomyCanvas.width = imageWrapper.clientWidth;
            anatomyCanvas.height = imageWrapper.clientHeight;

            // Draw image, scaled to fit canvas while maintaining aspect ratio
            const scale = Math.min(anatomyCanvas.width / imageToDraw.naturalWidth, anatomyCanvas.height / imageToDraw.naturalHeight);
            const scaledWidth = imageToDraw.naturalWidth * scale;
            const scaledHeight = imageToDraw.naturalHeight * scale;
            const offsetX = (anatomyCanvas.width - scaledWidth) / 2;
            const offsetY = (anatomyCanvas.height - scaledHeight) / 2;

            ctx.clearRect(0, 0, anatomyCanvas.width, anatomyCanvas.height); // Clear previous drawing
            ctx.drawImage(imageToDraw, offsetX, offsetY, scaledWidth, scaledHeight);

            // Draw Annotations only if loaded
            if (annotationsLoaded) {
                allAnnotations.filter(ann => ann.slice === currentSlice).forEach(annotation => {
                    // Convert percentage coordinates to pixel coordinates on the *scaled and offset* canvas image
                    const pixelPointX = (annotation.pointX / 100) * scaledWidth + offsetX;
                    const pixelPointY = (annotation.pointY / 100) * scaledHeight + offsetY;

                    const pixelLabelX = (annotation.labelX / 100) * scaledWidth + offsetX;
                    const pixelLabelY = (annotation.labelY / 100) * scaledHeight + offsetY;

                    // Get current theme colors from CSS variables
                    const annotationLineColor = getComputedStyle(document.body).getPropertyValue('--annotation-line-color').trim();
                    const annotationPointColor = getComputedStyle(document.body).getPropertyValue('--annotation-point-color').trim();
                    const annotationTextColor = getComputedStyle(document.body).getPropertyValue('--annotation-text-color').trim();
                    const annotationBgColor = getComputedStyle(document.body).getPropertyValue('--annotation-bg-color').trim();
                    const annotationBorderColor = getComputedStyle(document.body).getPropertyValue('--annotation-border-color').trim();


                    // Draw Line
                    ctx.beginPath();
                    ctx.moveTo(pixelPointX, pixelPointY);
                    ctx.lineTo(pixelLabelX, pixelLabelY);
                    ctx.strokeStyle = annotationLineColor;
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // Draw Point
                    ctx.beginPath();
                    ctx.arc(pixelPointX, pixelPointY, 4, 0, Math.PI * 2); // Radius 4
                    ctx.fillStyle = annotationPointColor;
                    ctx.fill();

                    // Draw Text Label Background
                    ctx.font = '500 14px Rubik'; // Ensure font is loaded before measureText
                    const textMetrics = ctx.measureText(annotation.text);
                    const textWidth = textMetrics.width;
                    const textHeight = 14 * 1.5; // Approximate height based on font size. Adjust if needed.

                    const bgPaddingX = 8; // Horizontal padding around text
                    const bgPaddingY = 6; // Vertical padding around text

                    ctx.fillStyle = annotationBgColor;
                    // Use ctx.roundRect for rounded rectangles (requires modern browser or polyfill)
                    // Fallback to rect if roundRect is not supported
                    if (ctx.roundRect) {
                        ctx.beginPath();
                        ctx.roundRect(
                            pixelLabelX - textWidth / 2 - bgPaddingX,
                            pixelLabelY - textHeight / 2 - bgPaddingY,
                            textWidth + bgPaddingX * 2,
                            textHeight + bgPaddingY * 2,
                            4 // border radius
                        );
                        ctx.fill();
                        ctx.strokeStyle = annotationBorderColor;
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    } else {
                        // Fallback for older browsers
                        ctx.fillRect(
                            pixelLabelX - textWidth / 2 - bgPaddingX,
                            pixelLabelY - textHeight / 2 - bgPaddingY,
                            textWidth + bgPaddingX * 2,
                            textHeight + bgPaddingY * 2
                        );
                        ctx.strokeStyle = annotationBorderColor;
                        ctx.lineWidth = 1;
                        ctx.strokeRect(
                            pixelLabelX - textWidth / 2 - bgPaddingX,
                            pixelLabelY - textHeight / 2 - bgPaddingY,
                            textWidth + bgPaddingX * 2,
                            textHeight + bgPaddingY * 2
                        );
                    }

                    // Draw Text
                    ctx.fillStyle = annotationTextColor; 
                    ctx.textBaseline = 'middle'; 
                    ctx.textAlign = 'center';   
                    ctx.fillText(annotation.text, pixelLabelX, pixelLabelY);
                });
            } else {
                console.warn("Annotations not yet loaded or failed to load. Skipping rendering of annotations for this slice.");
            }
        }

        // --- Main Update Function (called on slider change or load) ---
        function updateSlice() {
            const currentSlice = parseInt(sliceSlider.value);
            sliceNumberDisplay.textContent = `Slice: ${currentSlice} / ${imageCount}`;

            const imageToLoad = imagesCache[currentSlice];
            if (imageToLoad) {
                if (imageToLoad.complete) {
                    drawCurrentSlice();
                } else {
                    // If image is not yet loaded, set its onload to draw
                    imageToLoad.onload = drawCurrentSlice;
                    // Also update the src to ensure it starts loading if it wasn't already
                    // (though preloading should handle this, this is a fallback)
                    imageToLoad.src = `${imageFolderPath}${imageBaseName}${currentSlice}${imageExtension}`; 
                }
            } else {
                // This case should ideally not happen if preloadAllImages runs correctly
                console.error("Image not found in cache for slice:", currentSlice, ". Attempting to load directly.");
                const img = new Image();
                img.src = `${imageFolderPath}${imageBaseName}${currentSlice}${imageExtension}`;
                img.onload = drawCurrentSlice;
                imagesCache[currentSlice] = img; // Add to cache for future use
            }
        }

        // --- Initial Setup ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM content loaded. Initializing viewer."); 
            preloadAllImages(); // Start preloading all images

            // Set up initial canvas size based on wrapper
            // This needs to be done after DOMContentLoaded to ensure wrapper has dimensions
            function setCanvasSize() {
                anatomyCanvas.width = imageWrapper.clientWidth;
                anatomyCanvas.height = imageWrapper.clientHeight;
                // Only draw if image is already loaded, otherwise updateSlice will handle it
                if (imagesCache[sliceSlider.value] && imagesCache[sliceSlider.value].complete) {
                    drawCurrentSlice();
                }
            }
            setCanvasSize(); // Call once on load

            // Resize canvas on window resize to keep it responsive
            window.addEventListener('resize', setCanvasSize); // Just resize, updateSlice will handle redrawing


            loadAnnotations(); // Start loading JSON data and call updateSlice when done
            // updateSlice will be called by loadAnnotations or by image.onload (first image)
        });

        sliceSlider.addEventListener('input', updateSlice);
    </script>
</body>
</html>
