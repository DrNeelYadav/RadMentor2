<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Brain MRI Viewer - RadMentor</title>
    <link href="https://fonts.googleapis.com/css2?family=Rubik:wght@300;400;500;700&display=swap" rel="stylesheet"/>
    <style>
        /* Base styles for all themes */
        body {
            font-family: 'Rubik', sans-serif;
            margin: 0;
            transition: background-color 0.3s ease, color 0.3s ease;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: var(--bg-color);
            color: var(--text-color);
            flex-direction: column; /* Arrange items vertically */
            overflow: hidden; /* Prevent body scroll if content overflows slightly */
        }

        /* Light Theme Variables */
        body.light-theme {
            --bg-color: #f0f8ff; /* Very light blue/off-white background */
            --container-bg-color: #ffffff; /* Pure white container background */
            --text-color: #333333; /* Dark grey for general text */
            --heading-color: #0d47a1; /* Darker blue for headings */
            --box-bg-color: #e3f2fd; /* Light blue for boxes */
            --box-hover-bg-color: #bbdefb; /* Slightly darker light blue on hover */
            --box-border-color: #90caf9; /* Medium blue for box borders */
            --back-button-bg: #1e88e5; /* Standard blue button */
            --back-button-hover-bg: #1565c0; /* Darker blue button on hover */
            --slider-track-bg: #c5d9e8; /* Light blue for slider track */
            --slider-thumb-bg: #1e88e5; /* Blue for slider thumb */
            --annotation-text-color: #1a237e; /* Darker blue for annotation text */
            --annotation-bg-color: rgba(255, 255, 255, 0.95); /* More opaque white background */
            --annotation-border-color: #64b5f6; /* Light blue border */
            --annotation-line-color: #42a5f5; /* Medium blue for lines */
            --annotation-point-color: #f44336; /* Red dot for point */
        }

        /* Dark Theme Variables */
        body:not(.light-theme) {
            --bg-color: #004d5e;
            --container-bg-color: #043f4e;
            --text-color: #ffffff;
            --heading-color: #ffffff;
            --box-bg-color: #095a71;
            --box-hover-bg-color: #064a5c;
            --box-border-color: #043f4e;
            --back-button-bg: #00bcd4;
            --back-button-hover-bg: #0097a7;
            --slider-track-bg: #032b36; /* Darker track for dark theme */
            --slider-thumb-bg: #00bcd4; /* Brighter thumb for dark theme */
            --annotation-text-color: #e0f2f1; /* Light text for annotations */
            --annotation-bg-color: rgba(0, 0, 0, 0.85); /* More opaque black background */
            --annotation-border-color: #00bcd4; /* Accent color border */
            --annotation-line-color: #00bcd4; /* Accent color for lines */
            --annotation-point-color: #f44336; /* Red dot for point */
        }

        .viewer-container {
            background-color: var(--container-bg-color);
            border-radius: 12px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
            padding: 20px;
            margin: 20px auto;
            max-width: 1200px; /* Wider to accommodate side panels */
            width: 95%; /* Responsive width */
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: center; /* Center items horizontally */
        }

        .viewer-container h1 {
            color: var(--heading-color);
            font-size: 2.2rem;
            margin-bottom: 20px;
            text-align: center;
        }

        /* NEW: Container for Image + Side Panels */
        .viewer-content-area {
            display: flex; /* Use flexbox to arrange items horizontally */
            width: 100%; /* Take full width of parent viewer-container */
            align-items: flex-start; /* Align items to the top */
            gap: 10px; /* Space between image and panels */
        }

        /* Update image-wrapper */
        .image-wrapper {
            position: relative;
            flex-shrink: 0; /* Don't allow it to shrink */
            width: 512px; /* Set a fixed width for the image area - ADJUST THIS TO YOUR IMAGE RESOLUTION */
            height: 512px; /* Set a fixed height for the image area - ADJUST THIS TO YOUR IMAGE RESOLUTION */
            background-color: #000; /* Black background for imaging studies */
            border-radius: 8px;
            overflow: hidden; /* Hide anything outside the wrapper */
            box-shadow: inset 0 0 5px rgba(0,0,0,0.5);
            /* border: 1px solid red; /* For debugging image wrapper bounds */
        }

        .image-wrapper img {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain; /* Ensures the image fits within the wrapper without cropping */
            display: block;
            user-select: none;
            -webkit-user-drag: none;
            z-index: 8; /* Below labels and SVG lines */
        }

        /* NEW: Side Panels */
        .annotation-side-panel {
            flex-grow: 1; /* Allow panels to grow and take available space */
            min-width: 150px; /* Minimum width for the panels */
            max-width: 250px; /* Max width to prevent them from becoming too wide */
            background-color: var(--container-bg-color); /* Match container background */
            border-radius: 8px;
            padding: 10px;
            box-sizing: border-box;
            position: relative; /* For absolutely positioned labels within it */
            height: 512px; /* Match image height - ADJUST THIS TO YOUR IMAGE RESOLUTION */
            overflow-y: auto; /* Allow scrolling if labels exceed height */
            /* display: flex; flex-direction: column; gap: 5px; */ /* Not needed if using absolute positioning */
        }

        /* SVG Overlay for Lines and Points (MODIFIED) */
        .annotation-svg-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 9; /* Above image, below labels (which are now in side panels) */
            pointer-events: none; /* Crucial: allows clicks to pass through to image/labels */
            overflow: visible; /* Allows SVG elements to go slightly outside if needed */
        }

        /* Lines are hidden by default, visible on hover */
        .annotation-svg-overlay line {
            stroke: var(--annotation-line-color);
            stroke-width: 2;
            transition: opacity 0.3s ease;
            opacity: 0; /* Hidden by default */
            stroke-linecap: round;
        }
        .annotation-svg-overlay line.visible-on-hover {
            opacity: 0.7;
        }

        /* Circles are always visible, can change on hover */
        .annotation-svg-overlay circle {
            fill: var(--annotation-point-color);
            transition: all 0.1s ease; /* Transition for 'r' (radius) */
            opacity: 1; /* Always visible */
        }
        .annotation-svg-overlay circle.visible-on-hover-circle {
            r: 6; /* Make radius slightly larger on hover */
        }

        /* Annotation Label Styling (HTML Divs - MODIFIED) */
        .annotation-label {
            position: absolute; /* Positioned absolutely within its parent panel */
            background-color: var(--annotation-bg-color);
            color: var(--annotation-text-color);
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.9rem;
            font-weight: 500;
            white-space: nowrap;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            border: 1px solid var(--annotation-border-color);
            z-index: 11; /* Ensure labels are on top of other content if they overlap something */
            cursor: default;
            
            /* Vertical centering is handled by translateY, horizontal by left/right in JS */
            transform: translateY(-50%); 

            /* Visibility control */
            opacity: 0; 
            transition: opacity 0.3s ease; 
            display: block; 
        }

        /* No align-left/right CSS classes anymore, handled by JS styles */
        
        .annotation-label.show {
            opacity: 1;
        }

        /* Controls, Back Button, Loading Overlay (unchanged) */
        .controls {
            width: 100%;
            margin-top: 25px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        #sliceSlider {
            width: 90%;
            -webkit-appearance: none;
            appearance: none;
            height: 8px;
            background: var(--slider-track-bg);
            outline: none;
            opacity: 0.9;
            transition: opacity .2s;
            border-radius: 5px;
        }

        #sliceSlider:hover {
            opacity: 1;
        }

        #sliceSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--slider-thumb-bg);
            cursor: grab;
            box-shadow: 0 0 5px rgba(0,0,0,0.3);
        }

        #sliceSlider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--slider-thumb-bg);
            cursor: grab;
            box-shadow: 0 0 5px rgba(0,0,0,0.3);
        }

        #sliceNumberDisplay {
            font-size: 1.1rem;
            color: var(--text-color);
            font-weight: 500;
        }

        .back-button {
            display: block;
            width: 200px;
            margin: 40px auto 0;
            padding: 15px 25px;
            background-color: var(--back-button-bg);
            color: white;
            text-align: center;
            border-radius: 5px;
            text-decoration: none;
            font-weight: bold;
            font-size: 1.1rem;
            transition: background-color 0.3s ease;
        }
        .back-button:hover {
            background-color: var(--back-button-hover-bg);
        }

        /* Responsive adjustments (unchanged, but now works with fixed image size) */
        @media (max-width: 1000px) { /* Adjust breakpoint for wider layout */
            .viewer-content-area {
                flex-direction: column; /* Stack panels above/below image on smaller screens */
                align-items: center;
                gap: 15px;
            }
            .annotation-side-panel {
                width: 100%; /* Take full width when stacked */
                max-width: none; /* No max width when stacked */
                height: auto; /* Height adjusts to content */
                min-height: 80px; /* Ensure some height for stacked panels */
                display: flex; /* Keep flex for horizontal stacking of labels inside if needed */
                flex-direction: row; /* Labels flow horizontally now */
                flex-wrap: wrap; /* Labels wrap to next line */
                justify-content: center; /* Center labels when wrapped */
                gap: 10px; /* Space between labels in stacked panels */
                padding: 15px;
            }
            .annotation-label {
                position: relative; /* Labels become relative within panels when stacked */
                top: auto;
                left: auto;
                right: auto;
                transform: none; /* Remove absolute positioning transforms */
            }
            .annotation-svg-overlay {
                /* SVG still relative to image-wrapper, lines will be weird if not hidden */
                display: none; /* Hide lines and points when layout changes dramatically */
            }
        }

        @media (max-width: 768px) {
            .viewer-container {
                padding: 15px;
                width: 95%;
            }
            h1 {
                font-size: 2rem;
            }
            /* Image width can be responsive too if needed on very small screens */
            .image-wrapper {
                width: 100%;
                height: auto;
                padding-bottom: 100%; /* Maintain aspect ratio */
            }
        }
        @media (max-width: 480px) {
            h1 {
                font-size: 1.8rem;
            }
            .back-button {
                width: 100%;
                font-size: 1rem;
            }
        }
        /* Loading spinner CSS (unchanged) */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.85);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            z-index: 1000;
            transition: opacity 0.5s ease;
            opacity: 1;
            pointer-events: auto;
        }
        .loading-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #fff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin-bottom: 10px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="viewer-container">
        <h1>Axial Brain Anatomy</h1>

        <div class="viewer-content-area"> <div class="annotation-side-panel left-panel" id="leftAnnotationPanel"></div>
            
            <div class="image-wrapper">
                <img id="brainSliceImage" src="" alt="Brain Slice">
                <svg class="annotation-svg-overlay" id="annotationSvgOverlay"></svg>
                <div id="annotationOverlay"></div> 
                
                <div class="loading-overlay" id="loadingOverlay">
                    <div class="spinner"></div>&nbsp;Loading Annotations...
                </div>
            </div>
            
            <div class="annotation-side-panel right-panel" id="rightAnnotationPanel"></div>
        </div>

        <div class="controls">
            <input type="range" id="sliceSlider" min="1" max="24" value="1">
            <div id="sliceNumberDisplay">Slice: 1 / 24</div>
        </div>

        <a href="../../index.html" class="back-button">Back to MRI Anatomy</a>
    </div>

    <script>
        const imageCount = 24; 
        const imageBaseName = 'brain'; 
        const imageExtension = '.png'; 
        const imageFolderPath = './Images/'; 

        const annotationJsonPath = './annotations/'; 
        const imageDimensionMM = 512; // Original dimension from 3D Slicer coordinates

        const brainSliceImage = document.getElementById('brainSliceImage');
        const sliceSlider = document.getElementById('sliceSlider');
        const sliceNumberDisplay = document.getElementById('sliceNumberDisplay');
        const annotationOverlay = document.getElementById('annotationOverlay'); // Not used for labels anymore
        const annotationSvgOverlay = document.getElementById('annotationSvgOverlay'); 
        const loadingOverlay = document.getElementById('loadingOverlay');

        // NEW: References to the side panels
        const leftAnnotationPanel = document.getElementById('leftAnnotationPanel');
        const rightAnnotationPanel = document.getElementById('rightAnnotationPanel');

        let allAnnotations = []; 
        let annotationsLoaded = false; 
        const preloadedImages = []; 

        // --- Configuration for aligned labels ---
        const LABEL_PANEL_PADDING = 10; // Padding inside the side panels in pixels
        const LABEL_SPACING = 5;       // Vertical spacing between stacked labels in pixels
        const LINE_TO_IMAGE_EDGE_OFFSET = 5; // Distance from point to image edge, then line to label

        // --- THEME LOGIC (standard) ---
        function setTheme(theme) {
            if (theme === 'light') {
                document.body.classList.add('light-theme');
                localStorage.setItem('theme', 'light');
            } else {
                document.body.classList.remove('light-theme');
                localStorage.setItem('theme', 'dark');
            }
        }

        function setInitialTheme() {
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme === 'light') {
                document.body.classList.add('light-theme');
            } else {
                document.body.classList.remove('light-theme');
            }
        }
        setInitialTheme();
        // --- END THEME LOGIC ---

        // --- JSON FILENAMES (CRITICAL: THIS LIST MUST BE EXACT) ---
        const jsonFilenames = [
            "Angular Gyrus.json", "Aqueduct.json", "Caudate Nucleus.json", "Central Lobule.json",
            "Cerebellar Nuclei.json", "Cerebellar Peduncles.json", "Culmen.json", "Cuneus.json",
            "Declive.json", "Flocculus.json", "Fornix.json", "Frontal horn of LV.json",
            "Globus Pallidus.json", "Inferior Frontal Gyrus.json", "Internal Capsule.json",
            "Interpeduncular cistern.json", "Lateral Occipitotemporal gyrus.json",
            "Maxillary Sinus.json", 
            "Medial Frontal Gyrus.json",
            "Medulla Oblongata.json",
            "Mesencephalic cistern.json",
            "Midbrain.json",
            "Middle Frontal Gyrus.json",
            "Olfactory Sulcus.json", 
            "Optic Nerve.json", "Peduncles.json", "Pons.json", "Post Central Gyrus.json",
            "Posterior horn of LV.json", "Pre Central Gyrus.json", "Precuneus.json", "Putamen.json",
            "Septum Pellucidum.json", "Straight Gyrus.json", "Superior Frontal Gyrus.json",
            "Superior Parietal Lobule.json", "Suprachiasmatic cistern.json", "Supramarginal Gyrus.json",
            "Thallamus.json" 
        ];
        // --- END JSON FILENAMES ---

        // --- Data Loading and Processing ---
        async function loadAnnotations() {
            console.log("loadAnnotations started."); 
            loadingOverlay.classList.remove('hidden'); 

            const fetchPromises = jsonFilenames.map(filename =>
                new Promise((resolve, reject) => { 
                    const timeoutId = setTimeout(() => {
                        reject(new Error(`Fetch timed out for ${filename} after 10 seconds.`));
                    }, 10000); 

                    fetch(`${annotationJsonPath}${filename}`)
                        .then(response => {
                            clearTimeout(timeoutId); 
                            if (!response.ok) {
                                reject(new Error(`Failed to load ${filename}: ${response.statusText} (URL: ${response.url})`));
                            }
                            return response.json();
                        })
                        .then(jsonData => {
                            resolve(jsonData);
                        })
                        .catch(error => {
                            clearTimeout(timeoutId); 
                            reject(error); 
                        });
                })
            );

            try {
                const results = await Promise.all(fetchPromises);
                console.log("All JSON fetches and parsing completed."); 

                results.forEach(jsonData => {
                    if (!jsonData || !jsonData.markups || !Array.isArray(jsonData.markups)) {
                        console.warn("Skipping invalid or empty JSON data for a markup file (missing 'markups' array).", jsonData);
                        return;
                    }

                    jsonData.markups.forEach(markup => {
                        if (markup.type === "Fiducial" && Array.isArray(markup.controlPoints)) {
                            markup.controlPoints.forEach(cp => {
                                if (cp.position && cp.position.length === 3) {
                                    const sliceZ = cp.position[2]; 
                                    const imageSliceNumber = Math.round(sliceZ); 

                                    const pointX_percent = (cp.position[0] / imageDimensionMM) * 100;
                                    const pointY_percent = (cp.position[1] / imageDimensionMM) * 100;

                                    const cleanLabelText = cp.label.split(/-\d+/)[0].trim();

                                    allAnnotations.push({
                                        slice: imageSliceNumber,
                                        text: cleanLabelText,
                                        pointX: pointX_percent,
                                        pointY: pointY_percent,
                                    });
                                }
                            });
                        }
                    });
                });
                console.log("All annotations processed. Total annotations:", allAnnotations.length); 
                annotationsLoaded = true; 

            } catch (e) {
                console.error("Critical error during annotation loading or processing:", e); 
                alert("A critical error occurred while loading annotations: " + e.message + ". Check console for network/parsing details."); 
                annotationsLoaded = false; 
            } finally {
                loadingOverlay.classList.add('hidden'); 
            }
            updateSlice(); 
        }

        // --- Image Preloading ---
        function preloadAllImages() {
            console.log("Preloading images initiated.");
            for (let i = 1; i <= imageCount; i++) {
                const img = new Image();
                img.src = `${imageFolderPath}${imageBaseName}${i}${imageExtension}`;
                preloadedImages.push(img); 
            }
        }

        // --- Display Logic ---
        function updateSlice() {
            const currentSlice = parseInt(sliceSlider.value); 
            const imageUrl = `${imageFolderPath}${imageBaseName}${currentSlice}${imageExtension}`; 
            
            if (brainSliceImage.src !== new URL(imageUrl, window.location.href).href) {
                brainSliceImage.src = imageUrl;
            }

            sliceNumberDisplay.textContent = `Slice: ${currentSlice} / ${imageCount}`;

            // Clear previous SVG elements
            annotationSvgOverlay.innerHTML = ''; 
            // Clear previous labels from side panels
            leftAnnotationPanel.innerHTML = ''; 
            rightAnnotationPanel.innerHTML = '';

            // Reset for new slice's stacking logic
            let placedLabelsLeft = [];
            let placedLabelsRight = [];

            brainSliceImage.onload = function() {
                this.onload = null; 

                const wrapperRect = brainSliceImage.getBoundingClientRect(); // Get image element's current size
                const imageWidth = wrapperRect.width;
                const imageHeight = wrapperRect.height;
                // These are relative to the viewport, not the parent image-wrapper.
                // For SVG coordinates, we use 0-width/0-height of the SVG itself, which is 100% of parent image-wrapper.

                if (annotationsLoaded) {
                    // Sort annotations by their Y-coordinate for consistent stacking
                    const annotationsForCurrentSlice = allAnnotations.filter(ann => ann.slice === currentSlice)
                                                                     .sort((a, b) => a.pointY - b.pointY);

                    annotationsForCurrentSlice.forEach((annotation, index) => {
                        const pX_px_relative_to_image = (annotation.pointX / 100) * imageWidth; // Point X in pixels relative to image
                        const pY_px_relative_to_image = (annotation.pointY / 100) * imageHeight; // Point Y in pixels relative to image

                        // --- Create HTML Label div ---
                        const labelDiv = document.createElement('div');
                        labelDiv.classList.add('annotation-label');
                        labelDiv.textContent = annotation.text;
                        labelDiv.id = `label-${currentSlice}-${index}`;
                        
                        let targetPanel;
                        let placedLabelsArray; // Which stacking array to use
                        let isLeftPanel;

                        // Determine which side panel the label should go into
                        if (pX_px_relative_to_image < imageWidth / 2) { 
                            targetPanel = leftAnnotationPanel;
                            placedLabelsArray = placedLabelsLeft;
                            isLeftPanel = true;
                        } else {
                            targetPanel = rightAnnotationPanel;
                            placedLabelsArray = placedLabelsRight;
                            isLeftPanel = false;
                        }
                        
                        // Append to the correct panel temporarily to measure its actual dimensions
                        targetPanel.appendChild(labelDiv); 
                        const labelHeight = labelDiv.offsetHeight;
                        const labelWidth = labelDiv.offsetWidth; // Not strictly needed for stacking, but useful info

                        // --- Vertical Stacking Logic within the panel ---
                        // Calculate desired Y position within the panel, proportional to point's Y on image
                        // Need to convert image's 0-100% Y to panel's pixel height
                        let desiredLabelY_panel_px = (annotation.pointY / 100) * targetPanel.offsetHeight; 

                        // Ensure label is not off the top edge of the panel
                        desiredLabelY_panel_px = Math.max(desiredLabelY_panel_px, labelHeight / 2);

                        // Check for overlaps with already placed labels in this specific panel
                        for (let i = 0; i < placedLabelsArray.length; i++) {
                            const existingLabel = placedLabelsArray[i];
                            // Check if the current label's potential area overlaps with an existing one
                            // We compare the bottom of the existing label with the top of the current one
                            if (desiredLabelY_panel_px - (labelHeight / 2) < existingLabel.bottom + LABEL_SPACING) {
                                // Overlap detected. Adjust current label's Y to be below the existing one.
                                desiredLabelY_panel_px = existingLabel.bottom + LABEL_SPACING + (labelHeight / 2);
                            }
                        }

                        // Ensure label is not off the bottom edge of the panel (optional, but good)
                        desiredLabelY_panel_px = Math.min(desiredLabelY_panel_px, targetPanel.offsetHeight - (labelHeight / 2));

                        // Apply the final vertical position (relative to panel's top-left)
                        labelDiv.style.top = `${desiredLabelY_panel_px}px`;
                        
                        // Horizontal positioning within the panel
                        if (isLeftPanel) {
                            labelDiv.style.left = `${LABEL_PANEL_PADDING}px`; 
                        } else {
                            labelDiv.style.right = `${LABEL_PANEL_PADDING}px`; 
                        }

                        // Store this label's final position for future overlap checks in this panel
                        placedLabelsArray.push({
                            top: desiredLabelY_panel_px - (labelHeight / 2), // Actual top edge
                            bottom: desiredLabelY_panel_px + (labelHeight / 2), // Actual bottom edge
                            height: labelHeight,
                            element: labelDiv 
                        });

                        // --- Create SVG Line (slanting) ---
                        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        
                        // Line starts at the point (relative to image-wrapper)
                        line.setAttribute('x1', pX_px_relative_to_image);
                        line.setAttribute('y1', pY_px_relative_to_image);
                        
                        // Line goes to the appropriate edge of the image
                        let lineMidX_px;
                        if (isLeftPanel) {
                            lineMidX_px = 0; // Left edge of image-wrapper
                        } else {
                            lineMidX_px = imageWidth; // Right edge of image-wrapper
                        }

                        // Line's final endpoint (at the label's vertical center in the panel)
                        // Need to convert label's position relative to panel to relative to image-wrapper
                        // This involves: labelDiv.offsetTop (relative to panel) + panel.offsetTop (relative to image-wrapper parent)
                        // The SVG is relative to image-wrapper. So, lineY2 needs to be in image-wrapper's coordinate system.
                        const panelOffsetTop = targetPanel.offsetTop; // Get panel's Y offset relative to viewer-content-area
                        
                        // Since image-wrapper and panels are siblings in viewer-content-area,
                        // we need to calculate label's Y relative to image-wrapper's top (which is 0 in its own context).
                        // Assuming image-wrapper and panels are vertically aligned at their tops:
                        let lineY2_px = (labelDiv.offsetTop + (labelHeight / 2)); 


                        // If you want line to connect to the panel's edge, not just image edge
                        // lineX2_px will be the image edge
                        let lineX2_px_final;
                        if (isLeftPanel) {
                            lineX2_px_final = lineMidX_px + LINE_TO_IMAGE_EDGE_OFFSET; // End slightly inside image if connecting from left panel
                        } else {
                            lineX2_px_final = lineMidX_px - LINE_TO_IMAGE_EDGE_OFFSET; // End slightly inside image if connecting from right panel
                        }

                        line.setAttribute('x2', lineX2_px_final); 
                        line.setAttribute('y2', lineY2_px); // Line ends at the label's vertical center
                        line.id = `line-${currentSlice}-${index}`;
                        annotationSvgOverlay.appendChild(line);

                        // Create SVG Circle for the point (always visible)
                        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        circle.setAttribute('cx', pX_px_relative_to_image);
                        circle.setAttribute('cy', pY_px_relative_to_image);
                        circle.setAttribute('r', 4); 
                        circle.classList.add('show'); 
                        circle.id = `circle-${currentSlice}-${index}`; 
                        annotationSvgOverlay.appendChild(circle);

                        // --- Add Hover Interactivity ---
                        labelDiv.addEventListener('mouseover', () => {
                            document.getElementById(`line-${currentSlice}-${index}`)?.classList.add('visible-on-hover');
                            document.getElementById(`circle-${currentSlice}-${index}`)?.classList.add('visible-on-hover-circle');
                        });
                        labelDiv.addEventListener('mouseout', () => {
                            document.getElementById(`line-${currentSlice}-${index}`)?.classList.remove('visible-on-hover');
                            document.getElementById(`circle-${currentSlice}-${index}`)?.classList.remove('visible-on-hover-circle');
                        });
                        // --- End Hover Interactivity ---

                        setTimeout(() => labelDiv.classList.add('show'), 10);
                    });
                } else {
                    console.warn("Annotations not yet loaded or failed to load. Skipping rendering of annotations for this slice.");
                }
            };

            if (brainSliceImage.complete) {
                brainSliceImage.onload(); 
            }
        }

        // --- Initial Setup ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM content loaded. Initializing viewer."); 
            preloadAllImages(); 
            loadAnnotations(); 
        });

        sliceSlider.addEventListener('change', updateSlice); 
        
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                console.log("Window resized, updating slice.");
                updateSlice();
            }, 100); 
        });
    </script>
</body>
</html>
