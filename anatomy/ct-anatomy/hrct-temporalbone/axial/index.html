<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HRCT Temporal Bone - Axial - RadMentor</title>
    <link href="https://fonts.googleapis.com/css2?family=Rubik:wght@300;400;500;700&display=swap" rel="stylesheet"/>
    <style>
        /* Base styles for all themes */
        body {
            font-family: 'Rubik', sans-serif;
            margin: 0;
            transition: background-color 0.3s ease, color 0.3s ease;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: var(--bg-color);
            color: var(--text-color);
            flex-direction: column; /* Arrange items vertically */
            overflow: hidden; /* Prevent body scroll if content overflows slightly */
        }

        /* Light Theme Variables */
        body.light-theme {
            --bg-color: #f0f8ff; /* Very light blue/off-white background */
            --container-bg-color: #ffffff; /* Pure white container background */
            --text-color: #333333; /* Dark grey for general text */
            --heading-color: #0d47a1; /* Darker blue for headings */
            --box-bg-color: #e3f2fd; /* Light blue for boxes */
            --box-hover-bg-color: #bbdefb; /* Slightly darker light blue on hover */
            --box-border-color: #90caf9; /* Medium blue for box borders */
            --back-button-bg: #1e88e5; /* Standard blue button */
            --back-button-hover-bg: #1565c0; /* Darker blue button on hover */
            --slider-track-bg: #c5d9e8; /* Light blue for slider track */
            --slider-thumb-bg: #1e88e5; /* Blue for slider thumb */
            --annotation-text-color: #1a237e; /* Darker blue for annotation text */
            --annotation-bg-color: rgba(255, 255, 255, 0.95); /* More opaque white background */
            --annotation-border-color: #64b5f6; /* Light blue border */
            --annotation-line-color: #42a5f5; /* Medium blue for lines */
            --annotation-point-color: #f44336; /* Red dot for point */
        }

        /* Dark Theme Variables */
        body:not(.light-theme) {
            --bg-color: #004d5e;
            --container-bg-color: #043f4e;
            --text-color: #ffffff;
            --heading-color: #ffffff;
            --box-bg-color: #095a71;
            --box-hover-bg-color: #064a5c;
            --box-border-color: #043f4e;
            --back-button-bg: #00bcd4;
            --back-button-hover-bg: #0097a7;
            --slider-track-bg: #032b36; /* Darker track for dark theme */
            --slider-thumb-bg: #00bcd4; /* Brighter thumb for dark theme */
            --annotation-text-color: #e0f2f1; /* Light text for annotations */
            --annotation-bg-color: rgba(0, 0, 0, 0.85); /* More opaque black background */
            --annotation-border-color: #00bcd4; /* Accent color border */
            --annotation-line-color: #00bcd4; /* Accent color for lines */
            --annotation-point-color: #f44336; /* Red dot for point */
        }

        .viewer-container {
            background-color: var(--container-bg-color);
            border-radius: 12px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
            padding: 20px;
            margin: 20px auto;
            /* Adjusted max-width to accommodate image + right sidebar for labels */
            max-width: 1100px; /* 860px (image) + ~200px (label space) + padding */ 
            width: 90%; /* Responsive width */
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: center; /* Center items horizontally */
        }

        .viewer-container h1 {
            color: var(--heading-color);
            font-size: 2.2rem;
            margin-bottom: 20px;
            text-align: center;
        }

        /* Image and Overlay Container - Adjusted for 860x532px images + label sidebar */
        .image-wrapper {
            position: relative;
            /* Total width: image width (860px) + space for labels (e.g., 200px) */
            width: 1060px; /* 860px (image data) + 200px (label sidebar) */ 
            height: 532px; /* Set to your actual image's pixel height */
            background-color: #000; /* Black background for imaging studies */
            border-radius: 8px;
            overflow: hidden; /* Hide anything outside the wrapper */
            box-shadow: inset 0 0 5px rgba(0,0,0,0.5);
            /* For responsiveness, use padding-bottom to maintain aspect ratio */
            max-width: 100%; /* Ensure it shrinks on smaller screens */
            height: auto; /* Allow height to adjust */
            padding-bottom: calc(532 / 1060 * 100%); /* Maintain new aspect ratio based on total width */
        }

        .image-wrapper img {
            position: absolute;
            top: 0;
            left: 0; /* Image starts at the left of its wrapper */
            width: 860px; /* Set to the actual width of your image file */
            height: 100%; /* Will scale with wrapper height */
            object-fit: contain; /* Ensures the image fits within its designated width without cropping */
            display: block;
            user-select: none;
            -webkit-user-drag: none;
            z-index: 8; /* Below labels and SVG lines */
        }

        /* SVG Overlay for Lines and Points */
        .annotation-svg-overlay {
            position: absolute;
            top: 0;
            left: 0;
            /* SVG should cover the whole wrapper, including the label sidebar */
            width: 100%; 
            height: 100%;
            z-index: 9; /* Above image, below labels */
            pointer-events: none; /* Crucial: allows clicks to pass through to labels */
            overflow: visible; /* Allows SVG elements to go slightly outside if needed */
        }
        /* Lines are now HIDDEN BY DEFAULT, visible on hover */
        .annotation-svg-overlay line {
            stroke: var(--annotation-line-color);
            stroke-width: 2;
            transition: opacity 0.3s ease;
            opacity: 0; /* Changed: Hidden by default */
            stroke-linecap: round;
        }
        .annotation-svg-overlay line.visible-on-hover {
            opacity: 0.7; /* Line becomes visible on hover */
        }
        /* Circles are usually always visible, but can change on hover */
        .annotation-svg-overlay circle {
            fill: var(--annotation-point-color);
            transition: all 0.1s ease; /* Transition for 'r' (radius) */
            opacity: 1; /* Always visible */
            pointer-events: auto; /* Allow hovering on the circle */
        }
        .annotation-svg-overlay circle.visible-on-hover-circle {
            r: 6; /* Make radius slightly larger on hover */
        }

        /* Annotation Label Styling (HTML Divs) */
        .annotation-label {
            position: absolute; /* Positioned absolutely within image-wrapper */
            background-color: var(--annotation-bg-color);
            color: var(--annotation-text-color);
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.9rem;
            font-weight: 500;
            white-space: nowrap;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            border: 1px solid var(--annotation-border-color);
            z-index: 11; /* Ensure labels are on top */
            cursor: default;
            
            /* Align label to its center based on its 'top' and 'left' */
            transform: translate(-50%, -50%); 

            /* Visibility control: Labels are ALWAYS visible now */
            opacity: 1; /* Changed: Always visible */
            transition: opacity 0.3s ease; 
            pointer-events: auto; /* Allow hovering on the label */
        }

        /* The .show class is no longer needed for label visibility, 
           but can be kept for other purposes if desired later. */
        /* .annotation-label.show {
            opacity: 1;
        } */

        .controls {
            width: 100%;
            margin-top: 25px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        #sliceSlider {
            width: 90%;
            -webkit-appearance: none;
            appearance: none;
            height: 8px;
            background: var(--slider-track-bg);
            outline: none;
            opacity: 0.9;
            transition: opacity .2s;
            border-radius: 5px;
        }

        #sliceSlider:hover {
            opacity: 1;
        }

        #sliceSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--slider-thumb-bg);
            cursor: grab;
            box-shadow: 0 0 5px rgba(0,0,0,0.3);
        }

        #sliceSlider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--slider-thumb-bg);
            cursor: grab;
            box-shadow: 0 0 5px rgba(0,0,0,0.3);
        }

        #sliceNumberDisplay {
            font-size: 1.1rem;
            color: var(--text-color);
            font-weight: 500;
        }

        .back-button {
            display: block;
            width: 200px;
            margin: 40px auto 0;
            padding: 15px 25px;
            background-color: var(--back-button-bg);
            color: white;
            text-align: center;
            border-radius: 5px;
            text-decoration: none;
            font-weight: bold;
            font-size: 1.1rem;
            transition: background-color 0.3s ease;
        }
        .back-button:hover {
            background-color: var(--back-button-hover-bg);
        }

        /* Responsive adjustments for image wrapper */
        @media (max-width: 1080px) { /* Adjust breakpoint if needed */
            .image-wrapper {
                width: 100%; 
                height: auto;
                /* Maintain aspect ratio based on the total wrapper width (860 image + 200 label space = 1060 total) */
                padding-bottom: calc(532 / 1060 * 100%); 
            }
            .image-wrapper img {
                /* When shrinking, the image should also shrink to fit the *available* image portion */
                width: calc(860 / 1060 * 100%); /* Image takes its proportion of the new 100% width */
                /* Maintain height:100% */
            }
        }
        @media (max-width: 768px) {
            .viewer-container {
                padding: 15px;
                width: 95%;
            }
            h1 {
                font-size: 2rem;
            }
        }
        @media (max-width: 480px) {
            h1 {
                font-size: 1.8rem;
            }
            .back-button {
                width: 100%;
                font-size: 1rem;
            }
        }
        /* Loading spinner CSS */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.85);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            z-index: 1000;
            transition: opacity 0.5s ease;
            opacity: 1;
            pointer-events: auto;
        }
        .loading-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #fff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin-bottom: 10px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="viewer-container">
        <h1>HRCT Temporal Bone - Axial Section</h1> 

        <div class="image-wrapper">
            <img id="temporalBoneSliceImage" src="" alt="HRCT Temporal Bone Axial Slice">
            <svg class="annotation-svg-overlay" id="annotationSvgOverlay"></svg>
            <div id="annotationOverlay"></div>
            <div class="loading-overlay" id="loadingOverlay">
                <div class="spinner"></div>&nbsp;Loading Annotations...
            </div>
        </div>

        <div class="controls">
            <input type="range" id="sliceSlider" min="1" max="131" value="1"> 
            <div id="sliceNumberDisplay">Slice: 1 / 131</div>
        </div>

        <a href="../index.html" class="back-button">Back to HRCT Temporal Bone Menu</a> 
    </div>

    <script>
        // --- CONFIGURATION - CUSTOMIZED FOR HRCT TEMPORAL BONE AXIAL ---
        const imageCount = 131; // Total number of axial images
        const imageBaseName = ''; // Images are named 1.jpg, 2.jpg, etc.
        const imageExtension = '.jpg'; // File extension for your images
        const imageFolderPath = './images/'; // Path to your images folder (assuming relative to this index.html)
        
        const annotationJsonPath = './annotations/'; // Path to your annotations folder (assuming relative to this index.html)
        
        // These are the actual pixel dimensions of your *anatomical data portion*
        // assuming your 3D Slicer coordinates are based on a 512x512mm cube
        const IMAGE_MRI_DATA_DIMENSION_MM = 512; // Used for coordinate scaling FROM JSON
        
        // These are the actual pixel dimensions of your *full image files* (860x532px)
        const IMAGE_FILE_WIDTH = 860; // Actual width of the JPG/PNG file
        const IMAGE_FILE_HEIGHT = 532; // Actual height of the JPG/PNG file

        // Define the width of the dedicated label sidebar within the *image file itself*
        // Assuming labels are on the RIGHT side, so the MRI data is on the LEFT.
        const LABEL_SIDEBAR_WIDTH = IMAGE_FILE_WIDTH - IMAGE_MRI_DATA_DIMENSION_MM; // 860 - 512 = 348px

        // ADJUSTED: Increased offset to move labels further right into the empty space.
        // This is the X-coordinate relative to the *image-wrapper's left edge*
        // where the LEFT edge of the label column should begin.
        // It's the end of the MRI data + this offset. Increased from 15.
        const LABEL_OFFSET_FROM_MRI_EDGE = 40; // Pixels distance from MRI data edge to label's *closest edge*

        const LABEL_COLUMN_START_X = IMAGE_MRI_DATA_DIMENSION_MM + LABEL_OFFSET_FROM_MRI_EDGE; 

        // ADJUSTED: Increased vertical spacing for better readability and to reduce overlaps.
        const LABEL_VERTICAL_SPACING = 20; // Vertical spacing between stacked labels in pixels (Increased from 15)

        // --- JSON FILENAMES (CRITICAL: LIST ALL YOUR HRCT TEMPORAL BONE AXIAL JSON FILES HERE) ---
        const jsonFilenames = [
            // List your .mrk.json files here. Example:
            "Aditus.mrk.json", 
            "Ampulla of Superior SCC.mrk.json", 
            "Ampulla of Superior SCC.mrk.json", 
            "Arcuate eminence.mrk.json", 
            "Axis.mrk.json", 
            "Base of Cochlea.mrk.json", 
            "Body of Incus.mrk.json", 
            "Chorda tympani nerve.mrk.json", 
            "Cochlear aqueduct.mrk.json", 
            "Condylar Process.mrk.json",
            "Cupula of Cochlea.mrk.json",
            "Epitympanum.mrk.json",
            "Eustachian tube.mrk.json",
            "External Auditory canal.mrk.json",
            "Foramen Lacerum.mrk.json",
            "Foramen Ovale.mrk.json",
            "Foramen Spinosum.mrk.json",
            "Greater Petrosal Nerve.mrk.json",
            "Handle of Malleus.mrk.json",
            "Head of Malleus.mrk.json",
            "Hypoglossal Canal.mrk.json",
            "Hypotympanum.mrk.json",
            "Internal Acoustic Meatus.mrk.json",
            "Internal Carotid Canal.mrk.json",
            "Internal Genu.mrk.json",
            "Jugular fossa.mrk.json",
            "Labyrinthine part of 7th CN.mrk.json",
            "Lateral SCC.mrk.json",
            "Lenticular Process.mrk.json",
            "Long of process of Incus.mrk.json",
            "Mastoid Air cells.mrk.json",
            "Mastoid Process.mrk.json",
            "Mastoid part of 7th CN.mrk.json",
            "Mesotympanum.mrk.json",
            "Modiolous of Cochlea.mrk.json", 
            "Neck of Malleus.mrk.json",
            "Occipital Bone.mrk.json",
            "Occipitomastoid suture.mrk.json",
            "Odontoid Process.mrk.json",
            "Oval Window.mrk.json",
            "Petromastoid canal.mrk.json",
            "Pinna.mrk.json",
            "Posterior Condylar Canal.mrk.json",
            "Posterior SCC.mrk.json",
            "Ramus of Mandible.mrk.json",
            "Round Window.mrk.json",
            "Sigmoid sinus.mrk.json",
            "Sphenoid Bone.mrk.json",
            "Sphenosquamous suture.mrk.json",
            "Squamous part of the Temporal bone.mrk.json", 
            "Stapes foot plate.mrk.json",
            "Styloid Process.mrk.json",
            "Stylomastoid foramen.mrk.json",
            "Superior SCC.mrk.json",
            "TMJ.mrk.json",
            "Tegmen.mrk.json",
            "Tympanic Membrane.mrk.json",
            "Tympanic part of 7th CN.mrk.json",
            "Vestibular Aqueduct.mrk.json",
            "Vestibule.mrk.json",
            "Zygomatic bone.mrk.json"
        ];
        // --- END JSON FILENAMES ---
        // --- END CONFIGURATION ---

        const temporalBoneSliceImage = document.getElementById('temporalBoneSliceImage'); 
        const sliceSlider = document.getElementById('sliceSlider');
        const sliceNumberDisplay = document.getElementById('sliceNumberDisplay');
        const annotationOverlay = document.getElementById('annotationOverlay');
        const annotationSvgOverlay = document.getElementById('annotationSvgOverlay');
        const loadingOverlay = document.getElementById('loadingOverlay');

        let allAnnotations = [];
        let annotationsLoaded = false;
        const preloadedImages = [];

        // --- THEME LOGIC (standard, copied for consistency) ---
        function setTheme(theme) {
            if (theme === 'light') {
                document.body.classList.add('light-theme');
                localStorage.setItem('theme', 'light');
            } else {
                document.body.classList.remove('light-theme');
                localStorage.setItem('theme', 'dark');
            }
        }

        function setInitialTheme() {
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme === 'light') {
                document.body.classList.add('light-theme');
            } else {
                document.body.classList.remove('light-theme');
            }
        }
        setInitialTheme();
        // --- END THEME LOGIC ---

        // --- Data Loading and Processing ---
        async function loadAnnotations() {
            console.log("loadAnnotations started.");
            loadingOverlay.classList.remove('hidden');

            const fetchPromises = jsonFilenames.map(filename =>
                new Promise((resolve, reject) => {
                    const timeoutId = setTimeout(() => {
                        reject(new Error(`Fetch timed out for ${filename} after 10 seconds.`));
                    }, 10000);

                    fetch(`${annotationJsonPath}${filename}`)
                        .then(response => {
                            clearTimeout(timeoutId);
                            if (!response.ok) {
                                console.error(`Failed to load ${filename}. URL: ${response.url} Status: ${response.status} ${response.statusText}`);
                                reject(new Error(`Failed to load ${filename}: ${response.statusText}`));
                            }
                            return response.json();
                        })
                        .then(jsonData => {
                            resolve(jsonData);
                        })
                        .catch(error => {
                            clearTimeout(timeoutId);
                            reject(error);
                        });
                })
            );

            try {
                const results = await Promise.all(fetchPromises);
                console.log("All JSON fetches and parsing completed.");

                results.forEach(jsonData => {
                    if (!jsonData || !jsonData.markups || !Array.isArray(jsonData.markups)) {
                        console.warn("Skipping invalid or empty JSON data for a markup file (missing 'markups' array).", jsonData);
                        return;
                    }

                    jsonData.markups.forEach(markup => {
                        if (markup.type === "Fiducial" && Array.isArray(markup.controlPoints)) {
                            markup.controlPoints.forEach(cp => {
                                if (cp.position && cp.position.length === 3) {
                                    const sliceZ = cp.position[2];
                                    const imageSliceNumber = Math.round(sliceZ); 

                                    // Store raw MM values. We'll scale them based on displayed image size.
                                    allAnnotations.push({
                                        slice: imageSliceNumber,
                                        text: cp.label.split(/-\d+/)[0].trim(), 
                                        pointX_mm: cp.position[0], 
                                        pointY_mm: cp.position[1], 
                                    });
                                }
                            });
                        }
                    });
                });
                console.log("All annotations processed. Total annotations:", allAnnotations.length);
                annotationsLoaded = true;

            } catch (e) {
                console.error("Critical error during annotation loading or processing:", e);
                alert("A critical error occurred while loading annotations: " + e.message + ". Check console for network/parsing details and correct JSON filenames.");
                annotationsLoaded = false;
            } finally {
                loadingOverlay.classList.add('hidden');
            }
            updateSlice();
        }

        // --- Image Preloading ---
        function preloadAllImages() {
            console.log("Preloading images initiated.");
            for (let i = 1; i <= imageCount; i++) {
                const img = new Image();
                img.src = `${imageFolderPath}${i}${imageExtension}`; 
                preloadedImages.push(img);
            }
        }

        // --- Display Logic ---
        function updateSlice() {
            const currentSlice = parseInt(sliceSlider.value);
            const imageUrl = `${imageFolderPath}${currentSlice}${imageExtension}`; 
            
            temporalBoneSliceImage.src = imageUrl;
            sliceNumberDisplay.textContent = `Slice: ${currentSlice} / ${imageCount}`;

            annotationOverlay.innerHTML = ''; // Clear previous labels
            annotationSvgOverlay.innerHTML = ''; // Clear previous SVG elements

            temporalBoneSliceImage.onload = function() {
                this.onload = null;

                // Get actual rendered dimensions of the image element (which is also the SVG/overlay container)
                const imageDisplayWidth = temporalBoneSliceImage.offsetWidth; 
                const imageDisplayHeight = temporalBoneSliceImage.offsetHeight;

                // Calculate scaling factors for annotation points from MM (512x512) to displayed pixels (860x532)
                const scaleX_mri_data_to_display = imageDisplayWidth / IMAGE_FILE_WIDTH; // Scale for total width of image file
                const scaleY_mri_data_to_display = imageDisplayHeight / IMAGE_FILE_HEIGHT; // Scale for total height of image file

                // Calculate the actual pixel width of the MRI data portion as it's currently displayed
                const mriDataDisplayWidth_scaled = IMAGE_MRI_DATA_DIMENSION_MM * scaleX_mri_data_to_display;

                // Define the start and end X coordinates of the *MRI data itself* within the displayed image
                // Assuming MRI data starts at X=0 in the image file and the black strip is on the RIGHT.
                const mriDataRenderedLeftX = 0; 
                const mriDataRenderedRightX = mriDataRenderedLeftX + mriDataDisplayWidth_scaled;

                if (annotationsLoaded) {
                    const annotationsForCurrentSlice = allAnnotations.filter(ann => ann.slice === currentSlice)
                                                                     .sort((a, b) => a.pointY_mm - b.pointY_mm); // Sort by original Y (mm)

                    let placedLabelsRightColumn = []; // Stores {top, bottom, element} for stacking

                    annotationsForCurrentSlice.forEach((annotation, index) => {
                        // Convert point coordinates from MM to pixels relative to the displayed image (860x532)
                        const pX_px_displayed = annotation.pointX_mm * scaleX_mri_data_to_display;
                        const pY_px_displayed = annotation.pointY_mm * scaleY_mri_data_to_display;

                        // --- Create HTML Label div ---
                        const labelDiv = document.createElement('div');
                        labelDiv.classList.add('annotation-label');
                        labelDiv.textContent = annotation.text;
                        labelDiv.id = `label-${currentSlice}-${index}`;
                        
                        annotationOverlay.appendChild(labelDiv); 

                        // --- Calculate Label Position (including stacking) ---
                        const labelHeight = labelDiv.offsetHeight; // Get height after appending
                        const labelWidth = labelDiv.offsetWidth; // Get width after appending

                        // Label's target X (center of label)
                        // It's aligned to the LEFT edge of the right black strip, plus offset, plus half its width.
                        const labelTargetX_px = mriDataRenderedRightX + LABEL_OFFSET_FROM_MRI_EDGE + (labelWidth / 2); 
                        
                        const lineX2_px_at_mri_edge = mriDataRenderedRightX; // Line ends at the right edge of MRI data

                        // Initial desired Y (center of label) based on point's Y
                        let desiredLabelCenterY_px = pY_px_displayed; 

                        // Check for overlaps within the right column
                        // This loop tries to find the best non-overlapping vertical spot
                        let bestY = desiredLabelCenterY_px;
                        let foundFit = false;

                        // Try original Y first
                        if (!checkOverlap(desiredLabelCenterY_px, labelHeight, placedLabelsRightColumn, imageDisplayHeight)) {
                            foundFit = true;
                        } else {
                            // If overlaps, try moving up and down iteratively
                            let offset = LABEL_VERTICAL_SPACING;
                            const maxSearchOffset = Math.max(imageDisplayHeight, labelHeight * annotationsForCurrentSlice.length); // Max reasonable search distance

                            while (!foundFit && offset <= maxSearchOffset) {
                                // Try moving up
                                let tryY_up = desiredLabelCenterY_px - offset;
                                if (tryY_up - (labelHeight / 2) >= 0 && // Ensure label is within top boundary
                                    !checkOverlap(tryY_up, labelHeight, placedLabelsRightColumn, imageDisplayHeight)) {
                                    bestY = tryY_up;
                                    foundFit = true;
                                    break;
                                }
                                // Try moving down
                                let tryY_down = desiredLabelCenterY_px + offset;
                                if (tryY_down + (labelHeight / 2) <= imageDisplayHeight && // Ensure label is within bottom boundary
                                    !checkOverlap(tryY_down, labelHeight, placedLabelsRightColumn, imageDisplayHeight)) {
                                    bestY = tryY_down;
                                    foundFit = true;
                                    break;
                                }
                                offset += LABEL_VERTICAL_SPACING; // Increase offset for next iteration
                            }
                        }
                        
                        // Fallback if no ideal spot found (e.g., extremely dense labels, or not enough space)
                        if (!foundFit) {
                           // If still no fit after extensive search, just stack downwards from the last available spot.
                           // This ensures labels are always rendered, even if overlapping or off-screen.
                           if (placedLabelsRightColumn.length > 0) {
                               bestY = placedLabelsRightColumn[placedLabelsRightColumn.length - 1].bottom + LABEL_VERTICAL_SPACING + (labelHeight / 2);
                           }
                           // Ensure fallback doesn't go off screen bottom
                           bestY = Math.min(bestY, imageDisplayHeight - (labelHeight / 2));
                        }

                        // Ensure final Y is within image bounds after all adjustments (final clamping)
                        bestY = Math.max(bestY, (labelHeight / 2)); 
                        bestY = Math.min(bestY, imageDisplayHeight - (labelHeight / 2));


                        // Apply the final positions (these are for the label's CENTER due to transform: translate(-50%,-50%))
                        labelDiv.style.left = `${labelTargetX_px}px`; 
                        labelDiv.style.top = `${bestY}px`; 
                        labelDiv.style.pointerEvents = 'auto'; // Ensure hover works on labels

                        // Store this label's final actual (top, bottom) positions for future overlap checks
                        placedLabelsRightColumn.push({
                            top: bestY - (labelHeight / 2), // Actual top edge of the label
                            bottom: bestY + (labelHeight / 2), // Actual bottom edge of the label
                            element: labelDiv 
                        });

                        // --- Create SVG Line (slanted) ---
                        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        
                        // Line starts at the point on the MRI data
                        line.setAttribute('x1', pX_px_displayed);
                        line.setAttribute('y1', pY_px_displayed);
                        
                        // Line's X-endpoint is at the edge of the MRI data (transition to black strip)
                        line.setAttribute('x2', lineX2_px_at_mri_edge); 
                        line.setAttribute('y2', bestY); // Line ends at label's vertical center (adjusted Y)

                        line.id = `line-${currentSlice}-${index}`;
                        annotationSvgOverlay.appendChild(line);

                        // Create SVG Circle for the point (always visible)
                        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        circle.setAttribute('cx', pX_px_displayed);
                        circle.setAttribute('cy', pY_px_displayed);
                        circle.setAttribute('r', 4); 
                        circle.classList.add('show'); 
                        circle.id = `circle-${currentSlice}-${index}`; 
                        annotationSvgOverlay.appendChild(circle);

                        // --- Add Hover Interactivity ---
                        // Show line and highlight circle on hover over label or circle
                        const activateAnnotation = () => {
                            document.getElementById(`line-${currentSlice}-${index}`)?.classList.add('visible-on-hover');
                            document.getElementById(`circle-${currentSlice}-${index}`)?.classList.add('visible-on-hover-circle');
                        };
                        // Hide line and de-highlight circle on mouse out
                        const deactivateAnnotation = () => {
                            document.getElementById(`line-${currentSlice}-${index}`)?.classList.remove('visible-on-hover');
                            document.getElementById(`circle-${currentSlice}-${index}`)?.classList.remove('visible-on-hover-circle');
                        };

                        labelDiv.addEventListener('mouseover', activateAnnotation);
                        labelDiv.addEventListener('mouseout', deactivateAnnotation);
                        circle.addEventListener('mouseover', activateAnnotation);
                        circle.addEventListener('mouseout', deactivateAnnotation);
                        // --- End Hover Interactivity ---
                    });
                } else {
                    console.warn("Annotations not yet loaded or failed to load. Skipping rendering of annotations for this slice.");
                }
            };

            // Helper function to check if a potential label position overlaps with any already placed labels
            // Added imageDisplayHeight to ensure labels don't go out of bounds during overlap check
            function checkOverlap(testCenterY, testHeight, placedLabelsArr, containerHeight) {
                const testTop = testCenterY - (testHeight / 2);
                const testBottom = testCenterY + (testHeight / 2);

                // Check if the test label is already out of container bounds
                if (testTop < 0 || testBottom > containerHeight) {
                    return true; // Overlaps with container boundary
                }

                for (let i = 0; i < placedLabelsArr.length; i++) {
                    const existing = placedLabelsArr[i];
                    // Overlap if (testTop < existing.bottom + spacing AND testBottom > existing.top - spacing)
                    // Added a buffer LABEL_VERTICAL_SPACING for checking overlaps
                    if (testTop < (existing.bottom + LABEL_VERTICAL_SPACING) && testBottom > (existing.top - LABEL_VERTICAL_SPACING)) {
                        return true; // Overlaps with an existing label
                    }
                }
                return false; // No overlap
            }


            // If the image is already loaded (from cache or preloading), trigger the onload manually
            if (temporalBoneSliceImage.complete) {
                temporalBoneSliceImage.onload(); 
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM content loaded. Initializing viewer."); 
            preloadAllImages(); 
            loadAnnotations(); 
        });

        sliceSlider.addEventListener('input', updateSlice); // Using 'input' for continuous update if preferred
                                                          // Or use 'change' for update on release.
        
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                console.log("Window resized, updating slice.");
                updateSlice();
            }, 100); 
        });
    </script>
</body>
</html>
