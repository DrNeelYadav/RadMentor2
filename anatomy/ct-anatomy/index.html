<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HRCT Temporal Bone - Axial - RadMentor</title>
    <link href="https://fonts.googleapis.com/css2?family=Rubik:wght@300;400;500;700&display=swap" rel="stylesheet"/>
    <style>
        body {
            font-family: 'Rubik', sans-serif;
            margin: 0;
            transition: background-color 0.3s ease, color 0.3s ease;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: var(--bg-color);
            color: var(--text-color);
            flex-direction: column;
            overflow: hidden;
        }

        body.light-theme {
            --bg-color: #f0f8ff;
            --container-bg-color: #ffffff;
            --text-color: #333333;
            --heading-color: #0d47a1;
            --back-button-bg: #1e88e5;
            --back-button-hover-bg: #1565c0;
            --slider-track-bg: #c5d9e8;
            --slider-thumb-bg: #1e88e5;
            --annotation-text-color: #1a237e;
            --annotation-bg-color: rgba(255, 255, 255, 0.95);
            --annotation-border-color: #64b5f6;
            --annotation-line-color: #42a5f5;
            --annotation-point-color: #f44336;
        }

        body:not(.light-theme) {
            --bg-color: #004d5e;
            --container-bg-color: #043f4e;
            --text-color: #ffffff;
            --heading-color: #ffffff;
            --back-button-bg: #00bcd4;
            --back-button-hover-bg: #0097a7;
            --slider-track-bg: #032b36;
            --slider-thumb-bg: #00bcd4;
            --annotation-text-color: #e0f2f1;
            --annotation-bg-color: rgba(0, 0, 0, 0.85);
            --annotation-border-color: #00bcd4;
            --annotation-line-color: #00bcd4;
            --annotation-point-color: #f44336;
        }

        .viewer-container {
            background-color: var(--container-bg-color);
            border-radius: 12px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
            padding: 20px;
            margin: 20px auto;
            max-width: 1300px;
            width: 95%;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .viewer-container h1 {
            color: var(--heading-color);
            font-size: 2.2rem;
            margin-bottom: 20px;
            text-align: center;
        }

        .image-wrapper {
            position: relative;
            /* Set width to the new image file width */
            width: 1250px;
            max-width: 100%;
            background-color: #000;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.5);
            height: auto;
            /* Maintain aspect ratio of the new 1250x600 image */
            padding-bottom: calc(600 / 1250 * 100%);
        }

        .image-wrapper img {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
            display: block;
            user-select: none;
            -webkit-user-drag: none;
            z-index: 8;
        }

        .annotation-svg-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 9;
            pointer-events: none;
            overflow: visible;
        }

        .annotation-label {
            position: absolute;
            background-color: var(--annotation-bg-color);
            color: var(--annotation-text-color);
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.9rem;
            font-weight: 500;
            white-space: nowrap;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            border: 1px solid var(--annotation-border-color);
            z-index: 11;
            cursor: default;
            transform: translate(-50%, -50%);
            opacity: 1;
            transition: opacity 0.3s ease;
            pointer-events: auto;
        }
        
        .annotation-svg-overlay line {
            stroke: var(--annotation-line-color);
            stroke-width: 2;
            transition: opacity 0.3s ease;
            opacity: 0;
            stroke-linecap: round;
        }
        .annotation-svg-overlay line.visible-on-hover {
            opacity: 0.7;
        }
        .annotation-svg-overlay circle {
            fill: var(--annotation-point-color);
            transition: all 0.1s ease;
            opacity: 1;
            pointer-events: auto;
        }
        .annotation-svg-overlay circle.visible-on-hover-circle {
            r: 6;
        }

        .controls {
            width: 100%;
            margin-top: 25px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        #sliceSlider {
            width: 90%;
            -webkit-appearance: none; appearance: none;
            height: 8px;
            background: var(--slider-track-bg);
            outline: none;
            border-radius: 5px;
        }
        #sliceSlider::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none;
            width: 20px; height: 20px;
            border-radius: 50%;
            background: var(--slider-thumb-bg);
            cursor: grab;
        }
        #sliceSlider::-moz-range-thumb {
            width: 20px; height: 20px;
            border-radius: 50%;
            background: var(--slider-thumb-bg);
            cursor: grab;
        }
        #sliceNumberDisplay {
            font-size: 1.1rem;
            color: var(--text-color);
            font-weight: 500;
        }
        .back-button {
            display: block;
            width: 200px;
            margin: 40px auto 0;
            padding: 15px 25px;
            background-color: var(--back-button-bg);
            color: white;
            text-align: center;
            border-radius: 5px;
            text-decoration: none;
            font-weight: bold;
            font-size: 1.1rem;
            transition: background-color 0.3s ease;
        }
        .back-button:hover {
            background-color: var(--back-button-hover-bg);
        }
    </style>
</head>
<body>
    <div class="viewer-container">
        <h1>HRCT Temporal Bone - Axial Section</h1>
        <div class="image-wrapper">
            <img id="temporalBoneSliceImage" src="" alt="HRCT Temporal Bone Axial Slice">
            <svg class="annotation-svg-overlay" id="annotationSvgOverlay"></svg>
            <div id="annotationOverlay"></div>
        </div>
        <div class="controls">
            <input type="range" id="sliceSlider" min="1" max="131" value="1">
            <div id="sliceNumberDisplay">Slice: 1 / 131</div>
        </div>
        <a href="../index.html" class="back-button">Back to HRCT Temporal Bone Menu</a>
    </div>

    <script>
        // --- CONFIGURATION - UPDATED FOR PADDED IMAGES ---
        const imageCount = 131;
        const imageExtension = '.jpg';
        const imageFolderPath = './images/';
        const annotationJsonPath = './annotations/';
        
        // The dimension of the source medical data cube
        const IMAGE_MRI_DATA_DIMENSION_MM = 512;
        
        // **NEW**: Dimensions of the actual anatomy scan (the original 850x532 part)
        const ANATOMY_DATA_WIDTH = 850;
        const ANATOMY_DATA_HEIGHT = 532;

        // **NEW**: Padding added to the anatomy scan
        const PADDING_TOP = 34;
        const PADDING_LEFT = 400;

        // **NEW**: Final dimensions of your image files (e.g., 1250x600)
        const IMAGE_FILE_WIDTH = 1250;
        const IMAGE_FILE_HEIGHT = 600;

        // Label placement settings
        const LABEL_OFFSET_FROM_EDGE = 40;
        const LABEL_VERTICAL_SPACING = 10;

        // --- JSON FILENAMES ---
        const jsonFilenames = [
            "Aditus.mrk.json", "Ampulla of Superior SCC.mrk.json", "Ampulla of Superior SCC.mrk.json", "Arcuate eminence.mrk.json", "Axis.mrk.json", "Base of Cochlea.mrk.json", "Body of Incus.mrk.json", "Chorda tympani nerve.mrk.json", "Cochlear aqueduct.mrk.json", "Condylar Process.mrk.json", "Cupula of Cochlea.mrk.json", "Epitympanum.mrk.json", "Eustachian tube.mrk.json", "External Auditory canal.mrk.json", "Foramen Lacerum.mrk.json", "Foramen Ovale.mrk.json", "Foramen Spinosum.mrk.json", "Greater Petrosal Nerve.mrk.json", "Handle of Malleus.mrk.json", "Head of Malleus.mrk.json", "Hypoglossal Canal.mrk.json", "Hypotympanum.mrk.json", "Internal Acoustic Meatus.mrk.json", "Internal Carotid Canal.mrk.json", "Internal Genu.mrk.json", "Jugular fossa.mrk.json", "Labyrinthine part of 7th CN.mrk.json", "Lateral SCC.mrk.json", "Lenticular Process.mrk.json", "Long of process of Incus.mrk.json", "Mastoid Air cells.mrk.json", "Mastoid Process.mrk.json", "Mastoid part of 7th CN.mrk.json", "Mesotympanum.mrk.json", "Modiolous of Cochlea.mrk.json", "Neck of Malleus.mrk.json", "Occipital Bone.mrk.json", "Occipitomastoid suture.mrk.json", "Odontoid Process.mrk.json", "Oval Window.mrk.json", "Petromastoid canal.mrk.json", "Pinna.mrk.json", "Posterior Condylar Canal.mrk.json", "Posterior SCC.mrk.json", "Ramus of Mandible.mrk.json", "Round Window.mrk.json", "Sigmoid sinus.mrk.json", "Sphenoid Bone.mrk.json", "Sphenosquamous suture.mrk.json", "Squamous part of the Temporal bone.mrk.json", "Stapes foot plate.mrk.json", "Styloid Process.mrk.json", "Stylomastoid foramen.mrk.json", "Superior SCC.mrk.json", "TMJ.mrk.json", "Tegmen.mrk.json", "Tympanic Membrane.mrk.json", "Tympanic part of 7th CN.mrk.json", "Vestibular Aqueduct.mrk.json", "Vestibule.mrk.json", "Zygomatic bone.mrk.json"
        ];
        // --- END CONFIGURATION ---

        const temporalBoneSliceImage = document.getElementById('temporalBoneSliceImage'); 
        const sliceSlider = document.getElementById('sliceSlider');
        const sliceNumberDisplay = document.getElementById('sliceNumberDisplay');
        const annotationOverlay = document.getElementById('annotationOverlay');
        const annotationSvgOverlay = document.getElementById('annotationSvgOverlay');

        let allAnnotations = [];

        async function loadAnnotations() {
            const fetchPromises = jsonFilenames.map(filename => fetch(`${annotationJsonPath}${filename}`).then(res => res.json()));
            try {
                const results = await Promise.all(fetchPromises);
                allAnnotations = results.flatMap(data => 
                    data.markups?.flatMap(markup => 
                        markup.controlPoints?.map(cp => ({
                            slice: Math.round(cp.position[2]),
                            text: cp.label.split(/-\d+/)[0].trim(),
                            pointX_mm: cp.position[0],
                            pointY_mm: cp.position[1],
                        })) ?? []
                    ) ?? []
                );
                updateSlice();
            } catch (e) {
                console.error("Error loading annotations:", e);
                alert("A critical error occurred loading annotations.");
            }
        }
        
        function updateSlice() {
            const currentSlice = parseInt(sliceSlider.value);
            temporalBoneSliceImage.src = `${imageFolderPath}${currentSlice}${imageExtension}`;
            sliceNumberDisplay.textContent = `Slice: ${currentSlice} / ${imageCount}`;

            annotationOverlay.innerHTML = '';
            annotationSvgOverlay.innerHTML = '';

            const checkOverlap = (testY, height, placedLabels) => {
                const top1 = testY - height / 2;
                const bottom1 = testY + height / 2;
                for (const label of placedLabels) {
                    if (top1 < (label.bottom + LABEL_VERTICAL_SPACING) && bottom1 > (label.top - LABEL_VERTICAL_SPACING)) {
                        return true;
                    }
                }
                return false;
            };

            temporalBoneSliceImage.onload = function() {
                this.onload = null;

                const imageDisplayWidth = this.offsetWidth;
                const imageDisplayHeight = this.offsetHeight;

                // Overall scale factor of the displayed image vs the file
                const scaleX = imageDisplayWidth / IMAGE_FILE_WIDTH;
                const scaleY = imageDisplayHeight / IMAGE_FILE_HEIGHT;

                const annotationsForCurrentSlice = allAnnotations
                    .filter(ann => ann.slice === currentSlice)
                    .sort((a, b) => a.pointY_mm - b.pointY_mm);

                let placedLabels = [];

                annotationsForCurrentSlice.forEach((annotation, index) => {
                    // --- REVISED COORDINATE CALCULATION ---
                    // 1. Scale mm coordinate to the anatomy's pixel size (850x532)
                    const x_in_anatomy = (annotation.pointX_mm / IMAGE_MRI_DATA_DIMENSION_MM) * ANATOMY_DATA_WIDTH;
                    const y_in_anatomy = (annotation.pointY_mm / IMAGE_MRI_DATA_DIMENSION_MM) * ANATOMY_DATA_HEIGHT;

                    // 2. Add padding to get position in the final file (1250x600)
                    const x_in_file = x_in_anatomy + PADDING_LEFT;
                    const y_in_file = y_in_anatomy + PADDING_TOP;

                    // 3. Scale file position to the final displayed size
                    const pX_px_displayed = x_in_file * scaleX;
                    const pY_px_displayed = y_in_file * scaleY;

                    // --- Label and SVG Element Creation ---
                    const labelDiv = document.createElement('div');
                    labelDiv.className = 'annotation-label';
                    labelDiv.textContent = annotation.text;
                    annotationOverlay.appendChild(labelDiv);

                    const labelHeight = labelDiv.offsetHeight;
                    const labelWidth = labelDiv.offsetWidth;

                    let bestY = pY_px_displayed;
                    let foundFit = false;

                    // Stacking logic (same robust algorithm, now for the left column)
                    if (bestY - labelHeight / 2 >= 0 && bestY + labelHeight / 2 <= imageDisplayHeight && !checkOverlap(bestY, labelHeight, placedLabels)) {
                        foundFit = true;
                    }
                    if (!foundFit) {
                        for (let offset = 10; offset < imageDisplayHeight / 2; offset += 5) {
                            let tryUp = pY_px_displayed - offset;
                            if (tryUp - labelHeight / 2 >= 0 && !checkOverlap(tryUp, labelHeight, placedLabels)) { bestY = tryUp; foundFit = true; break; }
                            let tryDown = pY_px_displayed + offset;
                            if (tryDown + labelHeight / 2 <= imageDisplayHeight && !checkOverlap(tryDown, labelHeight, placedLabels)) { bestY = tryDown; foundFit = true; break; }
                        }
                    }
                    if (!foundFit) {
                        for (let scanY = (labelHeight / 2) + 5; scanY < imageDisplayHeight - (labelHeight / 2); scanY += 5) {
                            if (!checkOverlap(scanY, labelHeight, placedLabels)) { bestY = scanY; break; }
                        }
                    }
                    bestY = Math.max(bestY, labelHeight / 2);
                    bestY = Math.min(bestY, imageDisplayHeight - labelHeight / 2);

                    // Place label in the left sidebar
                    const labelTargetX_px = (PADDING_LEFT - LABEL_OFFSET_FROM_EDGE) * scaleX - (labelWidth / 2);
                    const lineEndX = PADDING_LEFT * scaleX;

                    labelDiv.style.left = `${labelTargetX_px}px`;
                    labelDiv.style.top = `${bestY}px`;
                    placedLabels.push({ top: bestY - labelHeight / 2, bottom: bestY + labelHeight / 2 });

                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', pX_px_displayed);
                    line.setAttribute('y1', pY_px_displayed);
                    line.setAttribute('x2', lineEndX);
                    line.setAttribute('y2', bestY);
                    annotationSvgOverlay.appendChild(line);

                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', pX_px_displayed);
                    circle.setAttribute('cy', pY_px_displayed);
                    circle.setAttribute('r', 4);
                    annotationSvgOverlay.appendChild(circle);

                    const activate = () => { line.classList.add('visible-on-hover'); circle.classList.add('visible-on-hover-circle'); };
                    const deactivate = () => { line.classList.remove('visible-on-hover'); circle.classList.remove('visible-on-hover-circle'); };
                    labelDiv.onmouseover = circle.onmouseover = activate;
                    labelDiv.onmouseout = circle.onmouseout = deactivate;
                });
            };

            if (temporalBoneSliceImage.complete) {
                temporalBoneSliceImage.onload();
            }
        }
        
        document.addEventListener('DOMContentLoaded', loadAnnotations);
        sliceSlider.addEventListener('input', updateSlice);
        window.addEventListener('resize', () => {
            clearTimeout(window.resizeTimeout);
            window.resizeTimeout = setTimeout(updateSlice, 100);
        });
    </script>
</body>
</html>
